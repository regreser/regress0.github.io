<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程师使用ChatGPT日常——高效理解技术细节</title>
      <link href="/2023/04/07/2023-04-07-ruan-jian-gong-cheng-shi-shi-yong-chatgpt-ri-chang-gao-xiao-li-jie-ji-zhu-xi-jie/"/>
      <url>/2023/04/07/2023-04-07-ruan-jian-gong-cheng-shi-shi-yong-chatgpt-ri-chang-gao-xiao-li-jie-ji-zhu-xi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近在整理一些关于Helm在大型企业中实践的内容，突然想到一个关于Helm的最佳实践：</p><blockquote><p>Chart names must be lower case letters and numbers. Words may be separated with dashes(-)</p></blockquote><p>在各种软件产品中，我不止一次看到对于大小写，破折号/下划线的要求。这次看到Helm的最佳实践，我依然很疑惑——为什么不使用大写字符和破折号会成为一个最佳实践？如果说为了命名风格一致，但为什么甚至会在某些软件中被直接禁止？比如Helm在install时如果存在大写或者下划线会直接报错。</p><p>关于这个问题我尝试使用传统的搜索引擎，但并不能很好的找到答案：<br><img src="https://s2.loli.net/2023/04/17/GB25rc38MsJFPVh.png" alt="搜索引擎找不到满意答案"></p><h1 id="通过ChatGPT来搜索答案"><a href="#通过ChatGPT来搜索答案" class="headerlink" title="通过ChatGPT来搜索答案"></a>通过ChatGPT来搜索答案</h1><p>从上图可以看到，搜出来的结果基本都是重复官方要求的不能使用下划线和大写字母。如果利用ChatGPT来找答案，是否能得到一个更好的答案呢？<br>以下是我的对话记录：<br><img src="https://s2.loli.net/2023/04/17/1neoM5wtO3rjDQx.png" alt="Helm命名规范与ChatGPT对话1"></p><p>从回答中可以看出是因为Kubernetes的命名规范限制了作为工具的Helm的命名，这很好理解。但是Kubernetes为什么会要求命名不能使用大写呢？继续追问：<br><img src="https://s2.loli.net/2023/04/17/Ktc53lgheHyznZa.png" alt="Helm命名规范与ChatGPT对话2"></p><p>经过两轮对话，ChatGPT已经给出了关键原因：为了避免操作系统中对于大小写不一致的处理方式可能会导致无法正确识别和处理对象。当然这也不够直接，继续问一个更具体的案例：<br><img src="https://s2.loli.net/2023/04/17/opfWqJ1KXG7eVNE.png" alt="Helm命名规范与ChatGPT对话3"></p><p>到这里，答案基本就明了：在Linux中能够创建myFile.txt和MyFile.txt的两个文件，但是如果同样的创建方式在Windows中执行一遍，就会出错。因此就有了通过规定只允许小写字母来避免这样的问题发声。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个过程，只用了大概2分钟，如果使用传统的搜索引擎，我并没有办法很快找到答案。ChatGPT在解决这个问题上有很大优势。<br>但ChatGPT在处理这样的日常任务时就完全没有缺点吗？当然不是。有以下这几个问题：</p><ol><li><p><strong>提问（Prompt）的方式决定回答的质量</strong></p><p> 相比于传统的搜索引擎靠关键字的方式，ChatGPT的问题方式事实上变得复杂了很多，同时也变得尤为关键。你描述的详细程度，描述的方式发生变化，得到的答案也不一样。同一个问题，我换一种问法，如下图所示：<br> <img src="https://s2.loli.net/2023/04/17/nmv89OB4WFAGLet.png" alt="不同的提问方式"><br> 这是一个相对直接的提问方式，得到的答案就和之前大不相同了。这里的解释是需要保持和Kubernetes命名规范一致，并没有像前文一样解释命名不一致可能会导致无法在部署时被Kubernetes正确解析和部署。</p></li><li><p><strong>回答的准确性</strong></p><p> 有时候ChatGPT的答案并不准确，相比之下，有一个靠谱的网站背书+一定数量的评论，这样的答案可信度更高。而ChatGPT的回答，比如：<br> <img src="https://s2.loli.net/2023/04/17/9j87B6AvayDWm1E.png" alt="难以验证的答案"><br> 我们是否敢直接用来做一些重要结论的依据呢？</p></li><li><p><strong>准确的回答就一定好？</strong></p><p> 我并不觉得准确的回答就一定好。很多时候我们使用搜索引擎去尝试解决一个问题，不只是为了解决问题本身，也希望能够从解决问题的过程中学到一些相关的知识，但是直接了当的回答，是否会一定程度的限制我们想象力的衍生呢？</p></li></ol><p>当然总的来说，将ChatGPT当作一个高级的搜索引擎来解决一些具体问题，的确是能够提高效率的，可以一试。</p>]]></content>
      
      
      <categories>
          
          <category> personal_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签名你的Git提交</title>
      <link href="/2022/12/11/2022-12-11-qian-ming-ni-de-git-ti-jiao/"/>
      <url>/2022/12/11/2022-12-11-qian-ming-ni-de-git-ti-jiao/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><p>什么是签名Git的提交？</p></li><li><p>Git提交为什么需要签名？</p></li><li><p>如何签名？</p></li><li><p>原理解析</p></li><li><p>引用</p></li><li><p>什么是签名Git的提交？</p></li></ol><h1 id="1-什么是签名Git的提交？"><a href="#1-什么是签名Git的提交？" class="headerlink" title="1. 什么是签名Git的提交？"></a>1. 什么是签名Git的提交？</h1><p>下图是一张被签名过后的提交(Commit)，在Github上的展示：</p><p><img src="https://s2.loli.net/2023/04/15/lj6R7JTSsNoMZLX.png" alt="Verified Commit样例"></p><p>与普通Commit的区别在于其多了一个<code>Verified</code>标识。这个标识能够被所有有权查看Commit的人看到，从而让大家更加信任这个Commit确实是作者本人提交的。而签名Git的提交正是显示<code>Verified</code>标识的最核心的一步。</p><h1 id="2-Git提交为什么需要签名？"><a href="#2-Git提交为什么需要签名？" class="headerlink" title="2. Git提交为什么需要签名？"></a>2. Git提交为什么需要签名？</h1><p>简单来说就是避免自己或者他人的Commit被伪造。</p><p>如今Git已然成为源码管理领域的重要成员，无数程序员使用Git作为其源码管理工具。那些以Git为核心的各种商业软件，如Github，Gitlab，Bitbucket等，每天接收大量的Git Commits。毫无疑问，这些Commit就是企业最重要的财产。即便如此，对于Commit本身的安全性，却没有得到太多的重视。当然Commit本身只是Git软件下的一个重要概念，保护Git软件的安全一定程度也能够保障Commit的安全，但这绝不是一个好的将Commit的安全放任不管的理由。要知道如果你什么都不做，Repository中的Commit是可以轻易被伪造的。而签名Git的提交正是为了解决这个问题而来。</p><h1 id="3-如何签名？"><a href="#3-如何签名？" class="headerlink" title="3. 如何签名？"></a>3. 如何签名？</h1><p>签名本身是一个简单的动作，尤其是在Git 2.34版本后，支持了SSH签名，对于那些本就使用SSH验证身份的用户就更加容易了。Github也支持使用GPG或者S/MIME进行签名，不过GPG相比于SSH更加复杂，S/MIME则主要用于企业。这里的例子以相对简单的Github上的SSH签名来演示。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>使用以下命令生成Key-Pair[1]</p><p><code>$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code></p><p>建议使用ed25519，相比于rsa 4096bit更快的速度，同时安全性也没有损失太多。</p><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>打开“setting”页面的“SSH and GPG keys”：</p><p><img src="https://s2.loli.net/2023/04/15/usaVeJYDH9SgyrA.png" alt="Github配置Key截图1">)<img src="https://s2.loli.net/2023/04/15/Qm5W6upnaTfwsSO.png" alt="Github配置Key截图2"></p><p>将上一步生成的公钥xxx.pub中的内容作为Signing Key上传到Github：<br><img src="https://s2.loli.net/2023/04/15/uaxN6wfCHP9XQr5.png" alt="Github配置Key截图3"></p><p>签名部分的配置就完成了，为了在Github上显示<code>Verified</code>标识，还需要打开“SSH and GPG keys”页面里的“Vigilant mode”[2]：<br><img src="https://s2.loli.net/2023/04/15/vRPa59sr8HU1W7T.png" alt="Github严格模式"></p><h2 id="配置git-3"><a href="#配置git-3" class="headerlink" title="配置git[3]"></a>配置git<sup>[3]</sup></h2><p>配置Git使用SSH来签名Commit</p><p><code>$ git config --global gpg.format ssh</code></p><p>配置Git使用指定路径的公钥作为SSH的Signing Key</p><p><code>$ git config --global user.signingkey ~/.ssh/ed25519.pub</code></p><h2 id="配置IDE（IntelliJ为例）"><a href="#配置IDE（IntelliJ为例）" class="headerlink" title="配置IDE（IntelliJ为例）"></a>配置IDE（IntelliJ为例）</h2><p>在commit页面上，点击设置，并勾选“Sign-off commit”，如下图所示：<br><img src="https://s2.loli.net/2023/04/15/LVMqlAdNsi1Qewa.png" alt="IntelliJ配置sign-off截图"></p><h2 id="签名并提交"><a href="#签名并提交" class="headerlink" title="签名并提交"></a>签名并提交</h2><p><code>$ git commit -S -m &quot;this is a signed commit&quot;</code></p><p>Push commit之后就能够在Commit页面中看到<code>Verified</code>标识了：<br><img src="https://s2.loli.net/2023/04/15/yfLw9FKSx6Mtzbq.png" alt="Commit Verified截图"></p><h1 id="5-原理解析"><a href="#5-原理解析" class="headerlink" title="5. 原理解析"></a>5. 原理解析</h1><p><img src="https://s2.loli.net/2023/04/15/dnqbH8Dx1iK9sa5.png" alt="Sign Commit原理解析示意图"></p><ol><li>提交者通过准备好的Private Key对Commit的内容摘要（Hash）进行签名，得到一个加密后的摘要值A，并将其存储在Commit信息中。</li><li>Github收到提交者上传的Commit后，使用对应的Public Key对Commit中的摘要加密信息A进行解密，得到Hash值</li><li>将这个Hash值与Commit中已存在的hash值进行比较，如果相等，则能够确定该Commit是由私钥所有者提交，也就验证了该Commit。</li></ol><h1 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h1><ol><li><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agenthttps:/gnupg.org/">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agenthttps://gnupg.org/</a></li><li><a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/displaying-verification-statuses-for-all-of-your-commits">https://docs.github.com/en/authentication/managing-commit-signature-verification/displaying-verification-statuses-for-all-of-your-commits</a></li><li><a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key">https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何有效地学习</title>
      <link href="/2022/08/11/2022-08-11-you-xiao-de-xue-xi/"/>
      <url>/2022/08/11/2022-08-11-you-xiao-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0. 目录"></a>0. 目录</h1><hr><ol><li>有效学习的价值</li><li>全览图</li><li>有效学习的方法</li><li>理论支撑</li><li>引用</li></ol><h1 id="1-有效学习的价值"><a href="#1-有效学习的价值" class="headerlink" title="1. 有效学习的价值"></a>1. 有效学习的价值</h1><hr><p><strong>学习好，玩的也好</strong>是很多人从小就有的追求。试想一下，放学回家，或者下班回家，很快便完成了这部分新知识点的学习，并提前完成安排的任务，剩下的时间就可以愉快地玩耍了。听起来好像不靠谱，天下没有完全的好事，但我想说这样的好事确实存在。关键在于有效学习。</p><p>我们花时间去学习，高效和低效的差距可能比想象的还大。高效学习5小时可能就能完成低效学习10小时的知识。省出来5小时，但如果长此以往，省出一年也不是不可能。这不是活脱脱的就比别人<strong>多活了一年</strong>？</p><p>这已经足够吸引人了，至于如何做，不同的人也会又不同的方式。我的方式就是下面这张全览图。</p><h1 id="2-全览图"><a href="#2-全览图" class="headerlink" title="2. 全览图"></a>2. 全览图</h1><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5p6b27j41j20u00u3q6m.jpg" alt="有效学习全览图"></p><h2 id="核心-Bloom分类法"><a href="#核心-Bloom分类法" class="headerlink" title="核心-Bloom分类法"></a>核心-Bloom分类法</h2><p>学习目标在我看来就是学习的核心。方向对了，努力才有价值。</p><p>Bloom分类法定义了学习教育的三大目标，分别是“认知”，“技能”，和“意愿”<sup>[1]</sup><sup>[2]</sup>。</p><p>其中最容易理解的就是”<strong>认知</strong>“，强调要达到<strong>记住</strong>和<strong>理解</strong>知识，从能够记住基本概念到能够理解概念并综合运用。</p><p>第二个部分是”<strong>技能</strong>“，与认知层面不同，该目标强调对知识的<strong>运用</strong>，从简单生疏的操作到复杂熟练的操作。</p><p>第三个部分容易被忽视，即“<strong>意愿</strong>”，强调学习的驱动力，从不明所以的愿意学到能够分析知识的价值。</p><p>根据Bloom分类法的理论，知识的学习都可以认为是围绕这三个部分展开。</p><h2 id="基础-记忆"><a href="#基础-记忆" class="headerlink" title="基础-记忆"></a>基础-记忆</h2><p>学习的基础是记住知识，记不住就无从谈学习。要有效的学习，必然要有效的记忆。</p><p>艾宾浩斯遗忘曲线是非常著名且历史悠久的发现。对于无规律可循的内容，你会在第一天快速遗忘掉大部分的内容，而后面遗忘速度逐渐变慢。</p><p>另外如果需要记忆的内容是有章法可循的，那遗忘得速率会整体变慢一些。但遗忘的高峰时期依然是在开始阶段。</p><h2 id="辅助方法-学习金字塔"><a href="#辅助方法-学习金字塔" class="headerlink" title="辅助方法-学习金字塔"></a>辅助方法-学习金字塔</h2><p>有了学习方向，明白了学习基础。就可以聊聊有效学习的具体方法了。而学习金字塔<sup>[3]</sup>，介绍了不同学习方式的效果，虽然2天后的记忆留存率无从考证，但是不同的学习方式存在不同效果确实是一个共识。</p><p>整体来看，主动学习的效果是要优于被动学习的。二者本质的区别在于Bloom分类法中的“<strong>意愿</strong>”。意愿更强烈，即便是在听课也往往会得到更好的效果。</p><p>对于学习金字塔中的不同学习方法，从”<strong>听课</strong>“到”<strong>教授</strong>“，其本质上的不同在于对知识能力的不同要求。教授对于”<strong>认知</strong>“、”<strong>技能</strong>“和”<strong>意愿</strong>“的要求都会高于”<strong>听课</strong>“，学习效果理应更好。</p><h2 id="辅助方法-学习技巧"><a href="#辅助方法-学习技巧" class="headerlink" title="辅助方法-学习技巧"></a>辅助方法-学习技巧</h2><p>在《暗时间》<sup>[4]</sup>一书中，刘未鹏也在一开始就介绍了自己对于记忆的理解。其中两个原则，一是“知识检索”，强调要建立知识的联系，增加检索知识的路径，从而能够更好地回忆起知识，并运用。另一个原则是“触类旁通”，强调可以通过抽象的方式，通过学习一个知识从而举一反三的学到多个知识。</p><p>这些都是非常好的帮助有效学习的方法，能够一定程度帮助我们更好的记忆。映射到Bloom分类法中，就是提高我们达成认知部分目标的能力。</p><h1 id="3-有效学习的方法"><a href="#3-有效学习的方法" class="headerlink" title="3. 有效学习的方法"></a>3. 有效学习的方法</h1><hr><h2 id="从记住的角度（认知）"><a href="#从记住的角度（认知）" class="headerlink" title="从记住的角度（认知）"></a>从记住的角度（认知）</h2><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>清晰的目标能让我们更加聚焦，投入的效率往往也能更高。关键是还防走偏。</p><p>明确目标只要是定义清楚学习这个知识的最终形态，比如想要学习的范围，想要达到的效果。</p><p>范围会包括从认知、技能、意愿三个方面出发的具体知识点，效果则是要达到的程度。</p><p>如果以学习Java为例，假设目标是”了解基础知识，入门Java“。</p><p>从认知角度来说，目标就是要学习Java的基本语法，变量和对象，内置的各种数据结构，IO，多线程等。能够记住和理解，并进行一些简单的练习应用。</p><p>从技能角度来说，目标就是能够在实践的项目中去使用这些基础知识。</p><p>从意愿角度来说，目标就是去了解Java的发展前景，去分享自己的学习经验和对Java的看法来获取到反馈。</p><h3 id="建立知识体系"><a href="#建立知识体系" class="headerlink" title="建立知识体系"></a>建立知识体系</h3><p>为自己的知识建立系统，将不同的知识关联起来。不仅有利于管理自己的知识，也有助于大脑记住这些知识。</p><p>比如将软件架构风格归为一类。单体，SOA（面向服务的架构，Service-Oriented Architecture），微服务，这些不同的架构风格的知识放在一起，不仅可以更深刻地理解他们，也能够在进行架构选型的时候，通过对比来提供更全面的选型需要的信息。</p><h3 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h3><p>如果已经有了知识体系，类似的知识往往就可以轻松高效地学习。即便不在同一个知识体系下，也可以通过对比类似的概念来进行对比学习。最终举一反三，记住一个就相当于记住了多个。省了不少力。</p><p>比如学习完Java，再去学习Python，那就可以对比两种语言不同的语法，变量和对象，IO等不同的实现。甚至还可以从对比中又思考出一些新的认识。</p><h3 id="及时复习"><a href="#及时复习" class="headerlink" title="及时复习"></a>及时复习</h3><p>为了能够记住，我们应当在学习知识后及时进行复习。尤其是头一天，复习的作用非常明显。</p><p>复习的手段可以多种多样，哪怕就是闭上眼简单回忆一下，也就能够把你回忆到的内容深刻地记下来，记得更久。</p><h2 id="从落地实践的角度（技能）"><a href="#从落地实践的角度（技能）" class="headerlink" title="从落地实践的角度（技能）"></a>从落地实践的角度（技能）</h2><h3 id="持续练习"><a href="#持续练习" class="headerlink" title="持续练习"></a>持续练习</h3><p>技能的提升和保持都需要持续不断地练习。在储备了一定程度的知识后，将其运用到真实的项目中，无疑是一个很好的验证学习成果，并收集反馈的机会。收集到的反馈又可以帮助我们去调整翻学习方向，学习方法，从而形成良性循环。</p><h3 id="虚拟的练习机会"><a href="#虚拟的练习机会" class="headerlink" title="虚拟的练习机会"></a>虚拟的练习机会</h3><p>根据自己的需求，构造一个虚拟的练习机会，可以是自己完全假象的简单场景，也可以是从别人那里听来的故事。虽然这样的机会相比于真实的机会简单许多，但也能够一定程度地锻炼自己的技能</p><h2 id="从个人驱动力的角度（情感）"><a href="#从个人驱动力的角度（情感）" class="headerlink" title="从个人驱动力的角度（情感）"></a>从个人驱动力的角度（情感）</h2><h3 id="压力驱动"><a href="#压力驱动" class="headerlink" title="压力驱动"></a>压力驱动</h3><p>如果我们意愿强烈地去做一件事，那效果往往会非常好。这种意愿可以来自于自身的兴趣爱好，但兴趣爱好并不那么好培养。相比之下更容易获得的是外在被动赋予个人的驱动力，比如项目的压力。当然前提是你得认同项目，这样才能达到“意愿”目标的“价值”及以上的层次，对于学习大有裨益。</p><p>从自身的经验来说，跟随项目学习也是一种很快速地学习方式。一方面项目压力带来的内驱动力的提升，让你更投入地去学习。另一方面，项目也会提供足够的上下文，帮助你学习。也正如学习金字塔中实践部分，是非常好的学习方式。</p><h3 id="反馈驱动"><a href="#反馈驱动" class="headerlink" title="反馈驱动"></a>反馈驱动</h3><p>通过不同方法给自己积极的反馈，有利于维持个人内驱力。比如可以将项目经验分享出去，进而获取到一些好的反馈来刺激自己获得更强的内驱动力。</p><h3 id="兴趣驱动"><a href="#兴趣驱动" class="headerlink" title="兴趣驱动"></a>兴趣驱动</h3><p>这可能是最难控制的方式。所谓的培养兴趣，并不容易，尤其是对于厌倦世俗，生活经验丰富的成年人。但这也同时是最好的方式之一了。</p><p>更多的去了解这项知识有趣的一面，可以更好地吸引自己。</p><h1 id="4-理论支撑"><a href="#4-理论支撑" class="headerlink" title="4. 理论支撑"></a>4. 理论支撑</h1><hr><p>正如全览图中所示，上面一节提到的“有效学习的方法”中的分析皆来源于Bloom分类法。该分类法提到的不同维度的学习目标，对应于实际上，也是不同场景下需要去实现的目标。</p><p>“<strong>认知</strong>”这部分的基础是“知识”，这些直观的知识需要的是能记住，学习方法更多的便是帮助记住这一点出发。</p><p>“<strong>技能</strong>”这部分则侧重于运用能力，如何熟练运用技能去解决问题。因此学习技巧是从实战练习出发。帮助加强技能块的能力提升。</p><p>“<strong>情感</strong>”这部分的重点在于个人意愿和价值观认同，因此学习方法上注重提高个人驱动力，进而帮助个人对于知识的认同。</p><h1 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h1><hr><p>[1] Bloom B S, Krathwohl D R. Taxonomy of educational objectives: the classification of educational goals. Book 1, Cognitive Domain[M]. Longman, 2020.</p><p>[2] Charlotte The Center for Teaching and Learning. Bloom’s Taxonomy of Educational Objectives [EB/OL]. <a href="https://teaching.charlotte.edu/services-programs/teaching-guides/course-design/blooms-educational-objectives">https://teaching.charlotte.edu/services-programs/teaching-guides/course-design/blooms-educational-objectives</a>, 2022-07-06.</p><p>[3] Wiki. Learning Pyramid [EB/OL]. <a href="https://upwikizh.top/wiki/Learning_pyramid">https://upwikizh.top/wiki/Learning_pyramid</a>, 2022-07-06.</p><p>[4] 刘未鹏. 暗时间[M]. 电子工业出版社, 2011.</p>]]></content>
      
      
      <categories>
          
          <category> personal_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超低利率的分期贷款能贷吗？</title>
      <link href="/2022/04/09/2022-04-09-chao-di-li-lu-de-fen-qi-dai-kuan-neng-dai-ma/"/>
      <url>/2022/04/09/2022-04-09-chao-di-li-lu-de-fen-qi-dai-kuan-neng-dai-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><hr><ol><li>先说结论</li><li>结论的理由</li><li>仔细聊聊</li><li>编程计算收益</li></ol><h1 id="01-先说结论"><a href="#01-先说结论" class="headerlink" title="01. 先说结论"></a>01. 先说结论</h1><p> <strong>90%</strong>的情况下是<strong>不能</strong>。</p><p>虽然贷款年利率3.6%，你的投资回报能到4%，但是你每年还是会亏掉1.66%。</p><h1 id="02-得出结论的原因"><a href="#02-得出结论的原因" class="headerlink" title="02. 得出结论的原因"></a>02. 得出结论的原因</h1><hr><p>90%是基于如下的假设（其中的百分比数据均为假设）：</p><ol><li><p>贷款的理由：1% 贷款救命，99% 加杠杆投资</p></li><li><p>年投资回报率：90% 回报率低于6.7%，10% 回报率高于6.7%</p><p><strong>贷款救命</strong>自不必说，必须得贷，和钱无关，不在讨论范围内。</p><p><strong>加杠杆投资</strong>和<strong>投资回报率低</strong>同时满足的人约等于90%，而满足这两个条件，你的投资基本就是亏定了，所以90%的情况是不能。</p></li></ol><p>选择6.7%的年投资回报率的原因是这个利率下，收支基本能平衡（贷款5年，3.6%年利率的情况下）。</p><p>具体计算过程如下：</p><p>假设我们打算分期贷款<strong>10w</strong>，银行给的超低年化利率是<strong>3.6%</strong>，贷款<strong>60期</strong>（60个月，5年）。</p><p>5年的利息总额是<strong>1.8w</strong>，每个月还<strong>1967元</strong>。</p><p>如果将这<strong>10w</strong>拿去投资，假设收益年化<strong>6.7%</strong>，</p><p>因为每个月还需要偿还本金和利息，所以5年的盈利是<strong>1.795w</strong>。</p><p>基本做到收支平衡。如果年收益率低于6.7%那就只能亏损了，如果能超过6.7%那当然还是能挣钱的。</p><p>然而实际上能做到<strong>4%</strong>的年化收益率在普通人中就算比较好的了，此时的5年盈利是<strong>0.97w</strong>。</p><p>最终亏损<strong>0.83w</strong>（1.8w - 0.97w），亏损率<strong>8.3%</strong>（0.83w ➗ 10w），平均每年约<strong>1.66%</strong>（6.8% ➗ 5）的亏损。</p><h1 id="03-仔细聊聊"><a href="#03-仔细聊聊" class="headerlink" title="03. 仔细聊聊"></a>03. 仔细聊聊</h1><hr><p>很多奔着挣钱去的人都无法理解为什么会这样。</p><p>明明贷款利率3.6%是低于我的投资回报率4%的，为什么还亏钱了？</p><p>关键点在于本金不同，<strong>贷款利率3.6%是一直按照贷款额度10w来计算利息</strong>，而你的<strong>4%年投资回报率是扣除月供后的金额来计算利息，本金肯定远低于10w</strong>。</p><p>用同样的例子来说明，贷款10w，贷5年（60期），贷款年利率3.6%，年投资收益率4.0%。</p><p>收益计算公式如下：<br>$$<br>收益 = 投资收益 - 贷款支出<br>$$</p><p>5年的贷款支出：<br>$$<br>10w \times 3.6% \times 5  = 1.8w<br>$$<br>5年的投资收益为：<br>$$<br>第1期投资回报E_1 + 第2期投资回报E_2 + 第3期投资回报E_3 + … + 第60期投资回报E_{60} = 0.97w<br>$$<br>随着本金用于偿还贷款利息而越来越少，每一期的投资收益会越来越少，收益计算如下：<br>$$<br>E_1 + E_2 + … + E_{60} ≈ 0.97w<br>$$</p><p>$$<br>E_1 = 当前本金10w \times 4.0% \div 12 ≈ 333<br>$$</p><p>$$<br>E_2 = (偿还第1期利息前本金100’000 - 上期月供1967 + 上月投资收益333) \times 4.0% \div 12 ≈ 328<br>$$</p><p>$$<br>E_3 = (偿还第2期利息前本金98’366 - 上期月供1967 + 上月投资收益328) \times 4.0% \div 12 ≈ 322<br>$$</p><center>...</center><p>$$<br>E_{60} = (偿还第59期利息前本金-6301 - 上期月供1967 + 上月投资收益-14) \times 4.0% \div 12 ≈ -21<br>$$</p><p>最终便可以得出结论：</p><p>亏损<strong>0.83w</strong>（1.8w - 0.97w），亏损率<strong>8.3%</strong>（0.83w ➗ 10w），平均每年约<strong>1.66%</strong>（6.8% ➗ 5）的亏损。</p><p>回顾一下上面的过程，本质上是存在两个原因导致投资结果与预期不符：</p><ol><li>产生收益的本金会逐月减少（每月需要还贷款）</li><li>用于计算贷款利息的贷款总额不会逐月减少（与按揭贷款不同，分期贷款的利息不会逐月减少，所以实际的贷款利率要比宣传的高得多）</li></ol><h1 id="04-编程计算收益"><a href="#04-编程计算收益" class="headerlink" title="04. 编程计算收益"></a>04. 编程计算收益</h1><hr><p>一个简单的递归可以很快实现这种本金持续变化的情况，代码如下：</p><h2 id="计算的代码片段（Java）"><a href="#计算的代码片段（Java）" class="headerlink" title="计算的代码片段（Java）"></a>计算的代码片段（Java）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterestCalculator</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> loanAmount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 贷款金额</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> loanRate<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 贷款年利率</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> interestRateMonthly<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 月收益率</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> installmentNumber<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 分期期数</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> installmentPayment<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 月供</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> serviceCharge<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 服务费</span>    <span class="token keyword">public</span> <span class="token function">InterestCalculator</span><span class="token punctuation">(</span><span class="token keyword">double</span> loanAmount<span class="token punctuation">,</span> <span class="token keyword">double</span> loanRate<span class="token punctuation">,</span> <span class="token keyword">double</span> interestRateMonthly<span class="token punctuation">,</span> <span class="token keyword">int</span> installmentNumber<span class="token punctuation">,</span> <span class="token keyword">double</span> serviceCharge<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loanAmount <span class="token operator">=</span> loanAmount<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loanRate <span class="token operator">=</span> loanRate<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>interestRateMonthly <span class="token operator">=</span> interestRateMonthly<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>installmentNumber <span class="token operator">=</span> installmentNumber<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>serviceCharge <span class="token operator">=</span> serviceCharge<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>installmentPayment <span class="token operator">=</span> loanAmount <span class="token operator">/</span> installmentNumber <span class="token operator">+</span> loanAmount <span class="token operator">*</span> loanRate <span class="token operator">/</span> <span class="token number">12</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calculateInterestIncome</span><span class="token punctuation">(</span><span class="token keyword">double</span> principal<span class="token punctuation">,</span> <span class="token keyword">int</span> installmentIndex<span class="token punctuation">,</span> <span class="token keyword">double</span> totalInterestIncome<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>installmentIndex <span class="token operator">></span> installmentNumber<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> totalInterestIncome<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第["</span> <span class="token operator">+</span> installmentIndex <span class="token operator">+</span> <span class="token string">"]期："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"本金："</span> <span class="token operator">+</span> principal<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"月供："</span> <span class="token operator">+</span> installmentPayment<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> interestThisMonth <span class="token operator">=</span> principal <span class="token operator">*</span> interestRateMonthly<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"利息收入："</span> <span class="token operator">+</span> interestThisMonth<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> principalNextMonth <span class="token operator">=</span> principal <span class="token operator">+</span> interestThisMonth <span class="token operator">-</span> installmentPayment<span class="token punctuation">;</span>        totalInterestIncome <span class="token operator">+=</span> interestThisMonth<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">calculateInterestIncome</span><span class="token punctuation">(</span>principalNextMonth<span class="token punctuation">,</span> installmentIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> totalInterestIncome<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calculateMargin</span><span class="token punctuation">(</span><span class="token keyword">double</span> principal<span class="token punctuation">,</span> <span class="token keyword">int</span> installmentIndex<span class="token punctuation">,</span> <span class="token keyword">double</span> totalInterestIncome<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">calculateInterestIncome</span><span class="token punctuation">(</span>principal<span class="token punctuation">,</span> installmentIndex<span class="token punctuation">,</span> totalInterestIncome<span class="token punctuation">)</span> <span class="token operator">-</span> serviceCharge <span class="token operator">-</span> loanAmount <span class="token operator">*</span> loanRate <span class="token operator">*</span> installmentNumber <span class="token operator">/</span> <span class="token number">12</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> loan </tag>
            
            <tag> finance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Windows开发环境</title>
      <link href="/2022/03/22/2022-03-22-da-jian-windows-kai-fa-huan-jing/"/>
      <url>/2022/03/22/2022-03-22-da-jian-windows-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><hr><ol><li>为什么要搭建Windows开发环境</li><li>开发环境需要搭建些什么</li><li>成品展示</li><li>搭建过程<ol><li>安装配置Terminal</li><li>安装配置WSLv2（配置Zsh以及主题powerlevel10k）</li><li>安装配置VSCode</li><li>安装配置IntelliJ</li><li>安装配置Typora</li><li>WSL中的开发语言环境</li></ol></li><li>总结</li></ol><h1 id="01-为什么要搭建Windows开发环境"><a href="#01-为什么要搭建Windows开发环境" class="headerlink" title="01. 为什么要搭建Windows开发环境"></a>01. 为什么要搭建Windows开发环境</h1><hr><p>作为一个互联网程序开发者，往往会基于MacOS来完成日常开发工作。毕竟MacOS有着很多的优势，比如与Linux系统更加接近，系统更加稳定，足够完善便捷的生态，华丽的外表，省心的使用体验…优势一箩筐，那我为什么还要搭建Windows开发环境？原因有几个，</p><ol><li>渴望Windows游戏工作两不误的体验</li><li>现在配置的Windows机器有很好的硬件基础</li><li>期待并想要尝试Windows的UI+Linux的开发体验</li><li>和Macbook互相备份，避免单点失败</li></ol><p>WSL(Windows Subsystem Linux)出现过后，一直想要好好地尝试一下，毕竟Windows上进行基于Linux的开发，这对于一个Windows和Linux的重度使用者，绝对是可以勾起足够多的兴趣的。</p><p>Windows的配置很好，毕竟打游戏得用好的硬件，在开机几秒的Windows上面开发应该会很不错吧。</p><p>开发虽然用惯了MacOS，但是日常的文档工作，比如PPT什么的，还是得用Windows，另外玩游戏，修照片都习惯在Windows上面完成。如果能借助WSL的能力，把开发这部分唯一不在MacOS上完成的活动也迁移到Windows上，那Windows作为一个大而全的平台，就真的是真香了。</p><p>基于此，我决定开始搭建我的Windows开发环境。</p><h1 id="02-开发环境需要搭建些什么"><a href="#02-开发环境需要搭建些什么" class="headerlink" title="02. 开发环境需要搭建些什么"></a>02. 开发环境需要搭建些什么</h1><hr><p>在开始之前，有对于在WSL上搭建开发环境的几个期望</p><ol><li>美观，不能比MacOS差太多</li><li>方便，尽量减少学习成本，切换成本</li><li>简单，容易安装和维护</li><li>功能完备，核心软件必须能够安装，非核心软件可以找到替代品</li></ol><p>简单分析了自己开发环境需要的功能，并基于以上的几个期望，列举了对应的软件，如下图，</p><p><img src="https://s2.loli.net/2022/04/03/XoPtHjS91Ramw45.png" alt="windows开发平台需求分析"></p><p>如上图所示，作为一个程序员，最重要的两个方面</p><ol><li>代码开发</li></ol><p>一部分是作为开发需要的语言环境，以及作为DevOps需要的语言环境</p><ol><li>文本编辑</li></ol><p>主要就是通过博客或其他类似方式产出想法。</p><p>总结来说，在Windows上需要安装的软件主要有，</p><ol><li><p>基础软件</p><ol><li>WSL</li></ol></li><li><p>工具软件</p><ol><li>Terminal</li></ol></li><li><p>IDE</p><ol><li>Intellij</li><li>VSCode</li></ol></li><li><p>Markdown编辑器</p><ol><li>Typora</li></ol></li></ol><p>在WSL环境中需要安装的软件主要有，</p><ol><li><p>工具软件</p><ol><li>ZSH</li><li>oh-my-zsh</li></ol></li><li><p>开发语言环境</p><ol><li>Java</li><li>JavaScript</li><li>Python</li><li>Go</li></ol></li><li><p>DevOps环境</p><ol><li>Docker</li><li>Terraform &amp;      AWS CLI</li><li>Kubernetes</li></ol></li></ol><h1 id="03-成品展示"><a href="#03-成品展示" class="headerlink" title="03. 成品展示"></a>03. 成品展示</h1><hr><h2 id="Windows中的WSL以及Terminal"><a href="#Windows中的WSL以及Terminal" class="headerlink" title="Windows中的WSL以及Terminal"></a>Windows中的WSL以及Terminal</h2><p><img src="https://s2.loli.net/2022/03/29/NmUJOwH6nxEbPgr.png" alt="Terminal示例"></p><p>WSL可以说是给Windows平台的程序开发注入了灵魂。当然必须是WSL2，WSL2相比于WSL1最大的不同在于WSL2是一个轻量级虚拟机，提供部分Linux的内核功能，而WSL1则是分享Windows的内核。这个区别就基本导致了Docker用户必须选择WSL2，因为Docker核心功能的运行就是基于Linux内核的Cgroup和Namespace功能。其他需要依赖Linux内核功能的软件也建议安装WSL2。</p><h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p><img src="https://s2.loli.net/2022/03/29/S52hD9nowCP6Ej7.png" alt="VSCode示例"></p><p>VSCode支持WSL。</p><h3 id="IntelliJ"><a href="#IntelliJ" class="headerlink" title="IntelliJ"></a>IntelliJ</h3><p><img src="https://s2.loli.net/2022/03/29/xsS7am1pArXNY3Z.png" alt="IntelliJ示例"></p><p>IntelliJ支持WSL。</p><p>通过一个简单的Gradle管理的SpringBoot程序来验证了WSL下的开发体验，除了需要进行一些额外的配置，基本可以达到MacOS下的开发体验了。</p><h1 id="04-搭建过程"><a href="#04-搭建过程" class="headerlink" title="04. 搭建过程"></a>04. 搭建过程</h1><hr><h2 id="安装Terminal"><a href="#安装Terminal" class="headerlink" title="安装Terminal"></a>安装Terminal</h2><p>通过Microsoft Store安装Terminal，参考<a href="https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701">安装教程</a>。</p><p><img src="https://s2.loli.net/2022/03/29/ZAYhEM15IuGKoXd.png" alt="Windows AppStore Terminal"></p><h2 id="安装配置WSL-v2"><a href="#安装配置WSL-v2" class="headerlink" title="安装配置WSL v2"></a>安装配置WSL v2</h2><h3 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h3><p>安装过程参考这个<a href="https://docs.microsoft.com/en-us/windows/wsl/install">安装教程</a></p><p>安装WSL</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span> C:\Windows\System32> wsl <span class="token operator">--</span>install <span class="token operator">-</span>d Ubuntu<span class="token operator">-</span>20<span class="token punctuation">.</span>04</code></pre><p>查看当前WSL的版本</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span> C:\Windows\System32> wsl <span class="token operator">-</span>l <span class="token operator">-</span>v  NAME              STATE           VERSION<span class="token operator">*</span> Ubuntu20<span class="token punctuation">.</span>04LTS    Running         2</code></pre><p>如果不是WSL v2，可以通过以下命令进行更改</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span> C:\Windows\System32> wsl <span class="token operator">--</span><span class="token function">set</span><span class="token operator">-</span>version Ubuntu20<span class="token punctuation">.</span>04LTS 2</code></pre><h3 id="安装配置Zsh"><a href="#安装配置Zsh" class="headerlink" title="安装配置Zsh"></a>安装配置Zsh</h3><p><a href="https://ohmyz.sh/#install">https://ohmyz.sh/#install</a></p><pre class=" language-shell"><code class="language-shell">$ sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></pre><h3 id="安装配置主题powerlevel10k"><a href="#安装配置主题powerlevel10k" class="headerlink" title="安装配置主题powerlevel10k"></a>安装配置主题powerlevel10k</h3><p><a href="https://github.com/romkatv/powerlevel10k#oh-my-zsh">https://github.com/romkatv/powerlevel10k#oh-my-zsh</a></p><p>下载主题</p><pre class=" language-shell"><code class="language-shell">$ git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</code></pre><p>配置主题</p><pre class=" language-shell"><code class="language-shell">$ sudo vim ~/.zshrc</code></pre><p>修改ZSH_THEHE</p><pre class=" language-shell"><code class="language-shell">ZSH_THEME="powerlevel10k/powerlevel10k"</code></pre><p>安装字体，避免乱码。</p><p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf">MesloLGS NF Regular.ttf</a></p><p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf">MesloLGS NF Bold.ttf</a></p><p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf">MesloLGS NF Italic.ttf</a></p><p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf">MesloLGS NF Bold Italic.ttf</a></p><h3 id="更换Terminal字体"><a href="#更换Terminal字体" class="headerlink" title="更换Terminal字体"></a>更换Terminal字体</h3><p><img src="https://s2.loli.net/2022/03/29/enNJPmzFrhUGxkR.png" alt="Terminal配置"></p><h2 id="安装配置IntelliJ"><a href="#安装配置IntelliJ" class="headerlink" title="安装配置IntelliJ"></a>安装配置IntelliJ</h2><h3 id="安装IntelliJ"><a href="#安装IntelliJ" class="headerlink" title="安装IntelliJ"></a>安装IntelliJ</h3><p>无明确需求，可以安装免费的Community版本。</p><h3 id="配置WSL"><a href="#配置WSL" class="headerlink" title="配置WSL"></a>配置WSL</h3><p>在IntelliJ中配置WSL参考这个<a href="https://www.jetbrains.com/help/idea/how-to-use-wsl-development-environment-in-product.html#wsl-terminal">配置教程</a></p><p>IntelliJ的Terminal不需要更换字体是因为IntelliJ的Terminal是内置的Windows Terminal，只要配置好了Windows Terminal就不需要重新配置了。</p><p><img src="https://s2.loli.net/2022/03/29/EwceRfC54tJIBXh.png" alt="IntelliJ配置"></p><h2 id="安装配置VSCode"><a href="#安装配置VSCode" class="headerlink" title="安装配置VSCode"></a>安装配置VSCode</h2><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>在官网下载对应版本进行安装即可。</p><h3 id="配置WSL-1"><a href="#配置WSL-1" class="headerlink" title="配置WSL"></a>配置WSL</h3><p>安装<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">远程开发扩展包</a>即可。</p><h3 id="更换VSCode-Terminal的字体"><a href="#更换VSCode-Terminal的字体" class="headerlink" title="更换VSCode Terminal的字体"></a>更换VSCode Terminal的字体</h3><p>更换字体是为了防止terminal显示乱码。同样更换为<code>MesloLGS NF</code></p><p><img src="https://s2.loli.net/2023/04/15/hNISgQiVfsGBEyR.png" alt="VSCode配置"></p><h2 id="安装配置Typora"><a href="#安装配置Typora" class="headerlink" title="安装配置Typora"></a>安装配置Typora</h2><p>一直使用Typora，很好的Markdown编辑器。Typora正式版发布后，也正式开始收费了，当然也可以继续使用免费的0.9.x版本。不升级的方式短暂使用没有问题，但是长期来看，还是需要来获得新功能已经安全漏洞和bug的修复，或者尽快找到替代品。</p><h2 id="WSL中配置语言环境"><a href="#WSL中配置语言环境" class="headerlink" title="WSL中配置语言环境"></a>WSL中配置语言环境</h2><p>有了上文配置过后的Terminal，就可以基于WSL2的Ubuntu进行各种开发语言环境的搭建了。这里就不一一列举。举个简单的例子，安装JDK11可以使用如下命令： </p><pre class=" language-shell"><code class="language-shell">$ sudo apt-get install openjdk-11-jdk</code></pre><h1 id="05-总结"><a href="#05-总结" class="headerlink" title="05. 总结"></a>05. 总结</h1><hr><p>一番短暂地体验之后，发现在WSL2上的开发体验其实和MacOS并没有太多差别。一方面Windows的可视化界面一直以来也没有什么问题，再加上Linux的文字接口用起来和MacOS虽有不同，但大致是一样的。而通过这一波操作，我的Windows电脑更加全能了，甚至还比MacOS更接近服务部署的Linux。我的这些游戏机和Office编辑机们恐怕没有想到过自己有一天竟然会成为一台主力开发机吧。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我选择MacOS作为开发主力机的理由</title>
      <link href="/2022/03/22/2022-03-22-wo-xuan-ze-macos-zuo-wei-kai-fa-zhu-li-ji-de-li-you/"/>
      <url>/2022/03/22/2022-03-22-wo-xuan-ze-macos-zuo-wei-kai-fa-zhu-li-ji-de-li-you/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>MacOS与Linux系统更加接近</li><li>MacOS比Windows更加稳定</li><li>MacOS完善且便捷的生态</li><li>MacOS足够华丽的外表</li><li>MacOS集成度更高</li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个互联网程序开发者，往往会基于MacOS来完成日常开发工作。可能的原因有很多，当然如果你是一个XCode用户，那自不用说。但很多场景下，Windows和MacOS都是可以一战的，那在这样的情况下，MacOS有什么优势？<img src="https://s2.loli.net/2022/04/03/DBSIKCGacJvYVp1.png" alt="macos"></p><h1 id="01-MacOS与Linux系统更加接近"><a href="#01-MacOS与Linux系统更加接近" class="headerlink" title="01. MacOS与Linux系统更加接近"></a>01. MacOS与Linux系统更加接近</h1><hr><p>相比Windows来说，MacOS的优势在于与Linux系统更加接近，毕竟大部分开发的服务都是运行在Linux系统中，使用类似的MacOS会有更好的一致性体验。不管是系统管理文件的方式，还是常用的命令，都比Windows更为接近Linux。</p><p>在你为了完成工作内容被迫掌握了Linux的技巧后，应该会更喜爱基本没有太多学习成本的MacOS。毕竟Windows的PowerShell哪怕做得再好，系统服务管理再怎么优化也是完全不同的一套指令和管理方式，何况Windows这些年的命令行工具的地位本来也和Linux，MacOS不一样。Windows就是设计用来进行键鼠操作。</p><p>简单才是硬道理。在很多情况下，MacOS更能够让开发者把精力更多地投入开发本身，这个理由选择MacOS就足够硬了。</p><h1 id="02-MacOS比Windows更加稳定"><a href="#02-MacOS比Windows更加稳定" class="headerlink" title="02. MacOS比Windows更加稳定"></a>02. MacOS比Windows更加稳定</h1><hr><p>Windows如果作为开发机，长时间运行不关机，基本是不太现实的，毕竟时不时蓝屏一下，多少让人有些抓狂。当然有弊也有利，这不是也让广大程序员在修电脑上得到了社会的认可嘛。相比之下，MacOS则稳定许多，不止是系统本身的稳定，基于系统之上的软件也是，崩溃的情况也更少。而系统稳定，让程序员专注在写代码这个事情上，MacOS也更胜一筹。</p><p>不过这个问题随着这些年Windows的不断发展，硬件水平不断提升，软件开发水平也稳步上升，差距变得没有那么明显了，Windows的各种驱动也更加稳定。从崩溃后的恢复能力来看，如今即便相对廉价的Windows机器由于SSD(Solid State Disk)的加持，开机都已经从几百秒变成了几秒，打开各种IDE也足够快，在这方面甚至都可以更胜一筹了，毕竟价格更加便宜。</p><h1 id="03-MacOS完善且便捷的生态"><a href="#03-MacOS完善且便捷的生态" class="headerlink" title="03.MacOS完善且便捷的生态"></a>03.MacOS完善且便捷的生态</h1><hr><p>MacOS由于多年来被无数开发者追捧，营造了一个很好的软件生态。互联网开发需要的软件，MacOS基本都能很好的覆盖，往往安全还非常简单，从安装到HelloWorld都可以非常方便地搞定，配合上MacOS的文字接口，甚至不用鼠标就可以完成。</p><p>相比之下，Windows则更加依赖鼠标。虽说鼠标推动了电脑的普及，是个非常棒的发明，但对于很多程序员来说，键盘明显重要得多，配合上称手的开发工具，输出速率可以直接爆炸。</p><h1 id="04-MacOS足够华丽的外表"><a href="#04-MacOS足够华丽的外表" class="headerlink" title="04. MacOS足够华丽的外表"></a>04. MacOS足够华丽的外表</h1><hr><p>三个方面的外表，<br>    1. 硬件外观<br>    2. UI的设计<br>    3. 分辨率</p><p>MacOS正常情况下，只会被运行在苹果公司出品的硬件设备上。无论是Macbook系列，还是MacMini系列，或者iMac，都可以说有着相当高的工艺水平。简洁的外观也可以说深得很大部分程序员的心。</p><p>苹果公司的UI设计近一二十年一直在引领整个行业，所以MacOS的UI的设计理念和实现都可以说足够强大。UI反面更为世人津津乐道的是iOS的UI。虽然MacOS和iOS的UI设计基本是同出一宗，不过MacOS毕竟使用场景和平台与iOS不一样，所以iOS的优势并完全等于MacOS的优势。MacOS在UI的优势更多的是，它提供了一种完全不一样的体验，以至于让大家可以有一种新的选择，而且这种选择并没有什么严重的短板。</p><p>如果说外观是相对主观的，那分辨率这方面Windows可以说确实落后了不少。这里主要是常常会用到的图标，界面的分辨率。在这个4k硬件基本都快要普及的时代，基于Windows系统的各种系统图标显示细腻度可以说完败MacOS。即便Windows10一直在优化，但是为了兼容大量的老旧软件，分辨率并不能全部优化。如果从MacOS切换到Windows，相信会有比较明显的感受。这种每天都会看到的东西，影响可以说足够大了。</p><h1 id="05-MacOS集成度更高"><a href="#05-MacOS集成度更高" class="headerlink" title="05.MacOS集成度更高"></a>05.MacOS集成度更高</h1><hr><p>虽说Windows和MacOS都不开源，但从硬件层面来说Windows显然要更开放一些，这也是市面上的Windows设备如此丰富的原因。更开放=更大的自由度。捣鼓Windows上的硬件基本是Windows使用者必备技能，程序员更胜。当然玩硬件确实能得到一些成就感，但新鲜劲过后，有时候也会是负担。MacOS从硬件到软件都没有那么多自由度，但如果过了自己爱捣鼓硬件的时期，MacOS以及苹果提供的一整套硬件解决方案，可以让你几乎不用投入额外精力就能够体验到当今数一数二的使用体验。当然，你只要给钱就行，用金钱换时间嘛。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的人生管理</title>
      <link href="/2022/03/06/2022-03-06-wo-de-ren-sheng-guan-li/"/>
      <url>/2022/03/06/2022-03-06-wo-de-ren-sheng-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><hr><ol><li>为什么要做人生管理</li><li>如何进行人生管理</li><li>人生管理的工具</li><li>总结</li></ol>]]></content>
      
      
      <categories>
          
          <category> personal_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life_management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我与软件工程的十年</title>
      <link href="/2021/07/24/2021-07-24-wo-yu-ruan-jian-gong-cheng-de-shi-nian/"/>
      <url>/2021/07/24/2021-07-24-wo-yu-ruan-jian-gong-cheng-de-shi-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>意外（2010）</li><li>第一次接触（2010）</li><li>第一次项目实践（2013）</li><li>第一次真实项目（2015）</li><li>起航（2017）</li><li>DevOps（2018）</li><li>需求分析（2020）</li><li>下一个十年（2021）</li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzs9mm2gfuj20is04mjrk.jpg" alt="DEV 0  2010  2021  第 一 次 真 項 目  接 D Ops  一 次 挼 触  求 分 析  第 一 次 項 目 践 "></p><h2 id="1-意外"><a href="#1-意外" class="headerlink" title="1. 意外"></a>1. 意外</h2><p>又一年普通高等学校招生全国统一考试（高考）结束，无数祖国的花朵要迈入大学校园，去学习以后可能要赖以生存的技能。我也是其中一个。</p><p>我原本是想学习建筑一类的专业，以后去设计修建高楼大厦，做一个Architect（架构师），之前模拟考试的分数也足够可以填报理想学校的建筑专业。可惜天不遂人愿，最终并没有模拟考试那样发挥稳定。</p><p>并没有Plan B的我，只能在志愿大全上不断翻找。无意中看到了“软件工程”，似乎冥冥之中的安排，我没有过多犹豫，填报了“软件工程”专业。那个时候“软件工程”这一类专业并没有现在这么火热，收入也算不得数一数二。可以说毫无竞争压力，我就被录取了。</p><p>似乎就像“意外”的换了志愿一样，我也“意外”地没有感受到得到录取通知书时候的喜悦。</p><p>不过那时候并不知道，我竟会与这个专业结下十年的缘分，而它也为我打开了一扇新世界的大门，从此山高海阔，任君遨游。</p><h2 id="2-第一次接触"><a href="#2-第一次接触" class="headerlink" title="2. 第一次接触"></a>2. 第一次接触</h2><p>很快就开学了，像往后许多年的每一个9月一样，一大波萌新在爸妈的陪伴下走进校园，又在学长学姐的带领下开启自己最难忘最青春洋溢的大学生活。</p><p>很快认识了室友，认识了同学，认识了辅导员，也第一次拿到了一摞摞的教材。谭浩强的《C++程序设计》第一次打开了我程序语言的大门。什么是程序，也在书中也学到了OOP（Object Oriented Programming）。</p><p>当时的我也不曾想，这些看起来简单却又似乎很深邃的知识会成为日后需要参悟多年的话题。</p><h2 id="3-第一次项目实战"><a href="#3-第一次项目实战" class="headerlink" title="3. 第一次项目实战"></a>3. 第一次项目实战</h2><p>学校的三年，学了很多门课程，但其实玩得更开心一些。以至于快要到招聘季了，并没有那么多底气。好在学校准备了一个暑期项目实训，大家都要去做一个模拟的实战项目，我也第一次接触到了真实项目的运作模式。一个简单的Web Application。经历了一套瀑布式的开发方式，最终由我们一个临时模拟的小组完成开发并交付。这让自己在慌乱中多了一丝慰藉。但后来才明白，这样的慰藉不过是空中楼阁，且不说瀑布模式已经算不上主流，更何况当时的项目实战还没有办法让学生自己走完整个的项目流程，开发毕竟也只是软件工程过程中的一部分而已。</p><h2 id="4-第一次真实项目"><a href="#4-第一次真实项目" class="headerlink" title="4. 第一次真实项目"></a>4. 第一次真实项目</h2><p>阴差阳错，在本科毕业之际保研了，学校的生活得以延续。在研究室，少不了作为“老板”的“员工”去完成一些工作。只是没想到第一次做项目就做了一个大项目，更没想到，整个3年的研究生生涯只做了这一个项目，最没想到的是，直到毕业后这个项目也没能交付。但无论如何，这都是我相对完整参与过的第一个项目。</p><p>仍然是Web Application，瀑布式的开发模式，多大数十人的开发规模。虽然没有能够较多的参与需求分析，但却是经历了需求分析的众多会议。效率并不高的会议，一定程度也让自己能够有更多时间去仔细思考，从中学习到更多内容。</p><p>前后投入了小一年的时间，最终没有等到项目上线，就不得不因为要准备毕业课题而中途退出。不算成功的项目，对我来说却也算是收获不少了。</p><h2 id="5-起航"><a href="#5-起航" class="headerlink" title="5. 起航"></a>5. 起航</h2><p>幸亏业界对毕业生的项目能力值期望不高，以至于我有幸能找到一家还不错的公司，以开启我随后至今约4年的职业发展之路，也同时开启了我真正“软件工程”的征程。</p><p>第一家公司以“软件工程”中的“敏捷”出名，公司有很多咨询师大拿，业界也算小有名气。当时并没有意识到我即将要做的，要学的正是“软件工程”的各种实践，尤其是“敏捷”实践。不得不说这已经偏离了我一开始以为的做一个代码输出砖家。但现在看来，这或许是我一个普通软件人不错的出路，毕竟纯技术专家的路线并非那么容易，不只是要有一些天赋，最重要的是要有训练场，有引导者，而后两者并非那么容易获得，甚至可以说是很难获得。</p><h2 id="6-DevOps"><a href="#6-DevOps" class="headerlink" title="6. DevOps"></a>6. DevOps</h2><p>DevOps早在2009年就已经在社区流行，我直到多年后才正式与它认识，并理解到DevOps其实是敏捷的一种延伸。</p><p>在我开始工作的第二年，由于当前项目的战略发生变化，大量的项目被砍，包括我所在的这个。公司向来不缺项目，我很快通过面试上了一个新项目。其实到现在我也无法估计，这个项目对我的职业发展，乃至人生有多大的影响。</p><p>不只是工作内容，从工作方式，甚至我的生活方式都发生了转变。由于出差，我来到了中国乃至世界最发达的地区之一，为业界数一数二的企业工作，工资收入也因为出差补助变得更丰裕一些。同时接触到的工作伙伴，也来自世界各地，不同背景。无论从技术，还是工作方式，挑战都不小。好在我很顺利地度过了，开始获得老板的认可，同时也获得团队的认可。</p><p>这个项目不仅是让我获得了DevOps的能力，更让我开阔了眼界，影响了我思考的方式，从而影响我做事的方式。最终我也在这个项目上乘上了职业发展的快车道，并开始在公司在项目上承担更多的职责。</p><h2 id="7-需求分析"><a href="#7-需求分析" class="headerlink" title="7. 需求分析"></a>7. 需求分析</h2><p>出差太久，便想回家了。于是在项目待了一年多后，毅然选择离开项目，加入了一个离家更近的项目，开始在新的项目上寻找一些新的挑战。这是一个新项目，我想我快要获得这么一个等待许久的机会了，我要接触到“软件工程”中的需求分析部分工作了。只是没想到，最终我并没有能完全参与进入需求分析，但却完全参与到了从“交付”到“运维”以及后续的“运维”阶段。同时这个项目也成为我在公司最长的项目。不知日后何年才能够打破这个1年9个月的记录。</p><p>这个项目拖延到3月份才算正式开始，正是新冠在中国最严重的阶段，而我们几个不同角色的同事需要飞赴海外参与项目启动。不过第一次参与需求分析，心情还是非常激动的。只是计划赶不上变化，刚到达目的地，当地的新冠疫情就爆发了，我只能在酒店隔离，通过极其不稳定的网络参加这次需求分析。这还不是最让人头疼的，由于我的背景调查一直没有通过，我甚至连远程接入会议的权限都没有，加上这新组建的团队也并没有形成默契，整个需求分析阶段其实并没有太好的体验。</p><p>需求分析阶段的尾声我总算是通过了背景调查，得以在项目正式交付时全力投入，项目最终跌跌撞撞地也算启动成功了。只是回过头来想，我最期待的那部分并没有发生，或者说并没有如期的发生。</p><p>虽然我没能如期等来一个完美的需求分析的体验，但是却与海外的隔离生活工作经历不期而遇。一切也算是我学习“软件工程”生涯中的命中注定吧。</p><h2 id="8-下一个十年"><a href="#8-下一个十年" class="headerlink" title="8. 下一个十年"></a>8. 下一个十年</h2><p>如今我从上一个项目退下来了，又以新的角色加入到新的项目中，期待的需求分析阶段又因为客户已经非常清楚上下文而草草收场。不过新的项目又有很多新的挑战在等着我。</p><p>“软件工程”的第一个十年，懵懵懂懂地就走过了。前半程完全没有意识，到后半程慢慢找到目标，积累到经验，看起来都在往好的方向上走。</p><p>接下来的十年，也可以说是职业生涯最可能发光的十年，能够在事业上有更多发展固然很好，不过更希望自己能够不负时光，早日把那些可能要探究一辈子的问题理解地更深刻一些。</p><p>第一个十年开始之初，我没能走上建筑行业Architect的道路，但这个十年，我确定是要走在“软件工程”行业Architect的道路上了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> retro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software_engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps的疑惑-实践概览</title>
      <link href="/2021/04/06/2021-04-06-devops-de-yi-huo-shi-jian-gai-lan/"/>
      <url>/2021/04/06/2021-04-06-devops-de-yi-huo-shi-jian-gai-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="DevOps前世今生"><a href="#DevOps前世今生" class="headerlink" title="DevOps前世今生"></a>DevOps前世今生</h2><p>从日常实践的角度来说，DevOps是一系列软件工程实践的汇总，包括部署流水线、自动化测试等等。这些实践都来自于业界对于实践的不断总结和提炼，不断优化去尝试更好的解决软件工程的若干问题。</p><p>这些实践也不是一开始就存在，而是不断的演进。讲到这些演进，就不得不说到被广泛采用的<code>瀑布式开发</code>。</p><p>瀑布式开发是最早的软件开发流程，提倡阶段性开发，多批次部署，不同角色相互合作，负责不同的软件开发阶段。比如设计则专注于设计，开发专注于开发，测试专注于测试。即便瀑布式开发已经不再主流的今天，这样的思想也一直存在，在不少的团队中，仍然存在不同的角色。</p><p>随着响应变化的需求越来越强烈和不可抗拒，敏捷开发应运而生。</p><p>敏捷开发缩短了瀑布模式的部署周期，提倡更快更频繁地部署，接受错误，并不断试错。团队规模也变得更小，因此也更灵活。</p><p>然而敏捷开发虽好，但也只是针对开发流程进行改进。软件生命周期很重要的一个阶段是“软件运行和维护阶段”，这也是软件产生价值的阶段（通常是运维团队负责），容易被开发团队忽略，但又是软件所有人最关心的部分之一。而这部分又正好是很容易出问题的部分。开发与运维团队配合的不默契导致了很多的问题。所以DevOps就是想要解决这些问题，让开发和运维团队更好的配合。更快更好地进行软件生命周期的最后一个，也是尤为重要的一个步骤——软件运行和维护阶段。</p><h2 id="不同角度的DevOps定义"><a href="#不同角度的DevOps定义" class="headerlink" title="不同角度的DevOps定义"></a>不同角度的DevOps定义</h2><h3 id="打破Dev和Ops部门墙"><a href="#打破Dev和Ops部门墙" class="headerlink" title="打破Dev和Ops部门墙"></a>打破Dev和Ops部门墙</h3><p>DevOps实践很重要的目的就是打破Dev和Ops的部门墙，让两个部门更好地合作。Dev想要更快的变更部署，推送新的功能给用户，Ops想要更稳定的运行系统，保证不出错，更好的服务用户。两个不同的相互冲突的目的，让Dev和Ops天然的难以合作。</p><p>DevOps则是希望通过从文化，软件开发实践的变革来打破这个部门墙。</p><p>这算是非常直接的一种解释，毕竟Dev和Ops放在一起组成了DevOps。</p><h3 id="敏捷的Ops"><a href="#敏捷的Ops" class="headerlink" title="敏捷的Ops"></a>敏捷的Ops</h3><p>另一方面，为了让软件工程的最后一公里（软件运行和维护阶段）敏捷起来，更好更快地部署上线。DevOps实践必不可少。通过进行部署流水线，自动化测试，Infrastructure as Code等实践来让软件运行和维护阶段更加适应变化。本质上，DevOps的内核也是精益敏捷。</p><h2 id="DevOps实践-1"><a href="#DevOps实践-1" class="headerlink" title="DevOps实践[1]"></a>DevOps实践<sup>[1]</sup></h2><p>说了这么多DevOps的相关信息，最终落地还是得看DevOps实践。</p><h3 id="实践一：文化变革"><a href="#实践一：文化变革" class="headerlink" title="实践一：文化变革"></a>实践一：文化变革</h3><p>进行DevOps实践，首当其冲的就是文化变革，如果不从组织最核心的人上进行变革，DevOps实践将难以为继。 </p><p>文化变革应该包括以下几个方面：</p><ol><li><h4 id="建立安全信任的环境"><a href="#建立安全信任的环境" class="headerlink" title="建立安全信任的环境"></a>建立安全信任的环境</h4><p><strong>允许试错</strong>：根据情况允许一定程度的错误，让团队成员都能够放心的去试错。明确失败是安全的，团队是为了证伪，而非证明。</p><p><strong>对事不对人</strong>：团队内部的成员也不应该相互抱怨（不对人），而应该努力纠正错误（对事）。</p><p><strong>持续进行</strong>：每个人都明确团队需要持续改进，而不是一步做到最好。</p></li></ol><ol start="2"><li><h4 id="明确持续改进的目标"><a href="#明确持续改进的目标" class="headerlink" title="明确持续改进的目标"></a>明确持续改进的目标</h4><p>建立了安全信任的基础，还需要有一个整体的目标，这个目标应当切合DevOps文化，需要根据团队的情况来定制化。制定目标可以遵循四步法，比如：</p><ol><li><p><strong>定义想要做的具体的事情</strong></p><p>如果生产问题频发，那相对应的目标就是减少生产问题，提高代码质量，减少手工测试，快速发布等。</p></li><li><p><strong>定义团队期望的做事方法</strong></p><p>针对想做的事情，提出应对之策，比如：开发团队编写自动化脚本，主动运行自动化测试，进行定期的Code Review等。</p></li><li><p><strong>提供培训，帮助团队完成</strong></p><p>针对这些想做的事，推出培训，比如：团队内部的自动化脚本workshop，或者请外部咨询师来提供相应培训。</p></li><li><p><strong>鼓励机制来促进完成</strong></p><p>衡量能力建设的成果，针对测试的能力建设来说，比如建立测试认证机制，对团队测试成熟度进行评价；或者建立自动化测试组合教练组，帮助团队提高。</p></li></ol></li></ol><ol start="3"><li><h4 id="明确行动原则"><a href="#明确行动原则" class="headerlink" title="明确行动原则"></a>明确行动原则</h4><p>为了能够建立安全信任的环境，并实现制定的持续改进的目标，势必需要全体成员进行落地行动，需要明确这些行动的指导原则：</p><ol><li><p><strong>价值导向</strong></p><p>以能够为最终用户创造价值为导向，没有创造这部分价值的就不应该去做。</p></li><li><p><strong>快速验证</strong></p><p>倾向于较快地发布，尽快把功能带给用户，也可以尽早验证。</p></li><li><p><strong>持续学习</strong></p><p>定期回顾，事件复盘。</p></li></ol></li></ol><ol start="4"><li><h4 id="明确度量原则"><a href="#明确度量原则" class="headerlink" title="明确度量原则"></a>明确度量原则</h4><p>文化变革中尤为重要的一点便是如何量化变革的效果。这需要在一开始便确定清楚。如果难以度量成果，那变革将难以维系。团队需要制定出符合自己的度量指标。</p><p>度量指标可以分为4类</p><ol><li><p><strong>引领性度量</strong></p><p>团队成员可以影响的。</p></li><li><p><strong>滞后性度量</strong></p><p>通过滞后的反馈来获取。</p></li><li><p><strong>可观测性度量</strong></p><p>比如发布频率，发布周期，MTBF（平均故障时间），MTTR（平均修复时间）。</p></li><li><p><strong>可行动性度量</strong></p><p>千行代码缺陷率，代码圈复杂度，重复度。</p></li></ol></li></ol><h3 id="实践二：架构设计"><a href="#实践二：架构设计" class="headerlink" title="实践二：架构设计"></a>实践二：架构设计</h3><p>DevOps的一个目的之一是解决软件工程中的第一次上线之后的运行维护，而一个臃肿的架构设计，势必会严重影响上线后的运行维护。毕竟如果对软件进行迭代满足新需求，修复已有Bug，或者进行系统增强满足更高要求的非功能性和安全需求，都需要基于当前架构进行代码修改，进而构建和发布。架构设计不够好，往往便会导致生产事故频发，为了修复一个问题却又引出更多问题。因此，为了保证DevOps实践的顺利开展，架构设计是基础。</p><p>如何进行架构设计才能更好的支持DevOps实践呢？</p><p>首先是架构设计的原则：</p><ol><li><p>满足持续交付（DevOps的重要实践之一）的架构要求</p><ol><li><p>为了测试而设计</p><p>缩短验证时间，加快变更速度</p></li><li><p>为了部署而设计</p><p>缩短部署时间和复杂度，加快部署速度，增强部署效率</p></li><li><p>为了监控而设计</p><p>增加获取反馈的渠道，而不是被动的等待用户反馈</p></li><li><p>为了扩展(Extensibility and Scalibility)而设计</p><p>支持团队人员扩展，支持自身系统扩展</p></li><li><p>为了失效而设计</p><p>快速的部署和发布失败后，如何快速的恢复</p></li></ol></li></ol><ol start="2"><li><p>系统拆分原则</p><ol><li>组件业务职责单一清晰</li><li>组件完成功能时，需要的依赖尽可能少（高内聚，低耦合）</li><li>易于构建和测试</li></ol></li></ol><p>如今存在多种被广泛使用的架构风格，无论哪一种架构风格，都应当尽可能的满足这些架构设计原则，才能更好支持DevOps实践。下面也针对不同的场景介绍一些架构风格。</p><ol><li><p>针对客户端软件的<strong>微核架构</strong></p><p>也被称为<strong>插件架构</strong>。该架构的核心功能被单独开发成为微核，所有业务功能通过插件方式实现。插件间的通信只通过核心框架进行。核心部分相对于软件整体来说是很小的，所以形象地被称为<strong>微核架构</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpm0p9b0ufj30hc0dc0sx.jpg" alt="image-20210410161504445"></p><p>微核架构满足了多个DevOps实践的架构设计原则：</p><ol><li><p>易测试</p><p>由于各个组件拆分为一个个的插件，测试也被分开，对于一部分功能的修改，测试难度相较于整体一起进行测试大大降低。</p></li><li><p>易部署发布</p><p>各个负责不同功能的插件都可以独立加载和卸载，可以很容易的发布新功能，或者卸载新功能。</p></li><li><p>易延展(Extensibility)</p><p>通过开发插件来扩展功能，方便快捷。</p></li><li><p>组件职责单一清晰</p><p>核心组件负责处理软件启动，通信基础模块，界面渲染等基础功能，不同功能由不同的插件来完成，组件职责单一且清晰。</p></li><li><p>组件间依赖少</p><p>插件（组件）都是通过核心组件作为唯一的连接点，插件间没有依赖。</p></li></ol><p>由于微核架构的核心组件通常是一个独立单元，无法进行横向扩展（增加核心组件数量），因此这种方式也会更适合用于客户端软件这种不需要横向扩展的场景。</p></li></ol><ol start="2"><li><p>针对企业服务端软件的<strong>微服务架构</strong></p><p>提倡将单一程序拆分为一组小的服务，各个服务间相互配合，完成之前由同一个程序完成的任务。</p><p>微服务架构同样也满足了DevOps实践的多个架构设计原则：</p><ol><li><p>易测试</p><p>修改一个服务，仅需要测试这一个服务。</p></li><li><p>易部署</p><p>每个服务可以单独部署，即使程序规模变大，部署难度也不会变得更大。</p></li><li><p>易扩展(Extensible and Scalibility)</p><p>扩展新功能可以基于任何一个服务进行，因而每个服务被拆分后都相对较小，因此易于扩展新功能，另外创建新的服务也很容易。</p><p>无论是纵向扩展（改变单一节点的性能），还是横向扩展（扩展更多的节点），每个服务都可以单独进行扩展，相比单个程序的模式更加容易扩展。</p></li><li><p>易于构建和测试</p><p>每个服务规模都被控制在一定范围内，相对于大规模的软件，更容易构建和测试</p></li></ol><p>微服务的模式也会由于服务被拆分开来，服务的数量会越来越多，1）服务间的相互依赖，网络通信都会越来越复杂，难以处理；2）业务流程中的原子操作也变得更加复杂；3）跨服务的测试和开发都因为需要同时部署和启动多个服务而变得困难；4）公共类库的审计管理也会根据微服务的数量而对应的增加。</p></li></ol><ol start="3"><li><p>针对初创公司产品项目的<strong>单体架构</strong></p><p>单体架构最大的优势就是在规模较小时。</p><ol><li><p>易于部署</p><p>由于整个程序仅有一个服务，部署一次就可以完成，因此部署逻辑通常非常简单。</p></li><li><p>易于扩展</p><p>程序可以很容易地进行横向和纵向的扩展。并且在规模较小时可以简单快速地开发新功能。</p></li><li><p>易于构建和测试</p><p>所有组件都融合在一起，无论在本地还是在CI工具上都可以很方便地构建。</p><p>测试也是同样的道理</p></li></ol><p>如果在规模逐渐扩大的情况下，缺点就会立即展现出来。</p><ol><li><p>大规模不易延展</p><p>由于所有服务耦合在一起，耦合的服务足够多的时候，不太容易延展新的功能。</p></li><li><p>大规模不易部署</p><p>任意的服务修改，都需要重新部署整个应用。</p></li></ol><p>因此这种架构设计，要想更好的进行DevOps实践，需要尽量将软件规模维持在一个较小的体量，否则则需要投入大量精力才能较好地落地DevOps实践。</p></li></ol><h3 id="实践三：部署流水线"><a href="#实践三：部署流水线" class="headerlink" title="实践三：部署流水线"></a>实践三：部署流水线</h3><p>部署流水线承包了从源码到部署发布的过程，算得上是DevOps实践的核心部分。想要快速稳定地发布新功能，部署流水线的性能必须得好。那如何能够又快又稳地完成这个过程呢？</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ol><li><p>一次构建，多环境部署</p><p>保证各个环境部署的软件是一致的，这样在低环境的各种验证结果更有保障，降低高环境与低环境出现不一致的可能性。</p></li><li><p>与业务逻辑松耦合</p><p>不要将构建和部署相关的内容存放在部署流水线中，而应该存放到业务代码库中。部署流水线中如果包含了业务逻辑，那业务的修改可能会需要通过修改部署流水线来实现，这会极大的增加部署流水线的管理难度。</p></li><li><p>并行化</p><p>并行化可以很大程度提高部署流水线的执行速度。部署流水线的执行速度对于整个部署流水线尤为重要，如果我们可以为每次提交都进行构建和对应的测试，那主分支的代码质量将得到极大的保障，进而保证主分支长期随时可部署。</p></li><li><p>快速反馈</p><p>由于资源有限，部署流水线执行速度也有限，因此需要将那些优先级更高的任务放到流水线的前期，以便更早地进行反馈。帮助团队实现更快地迭代。</p></li><li><p>重要反馈</p><p>部署流水线任务的执行优先级，不能仅仅考虑执行速度，重要程度也必须考虑。</p></li></ol><h4 id="实践原则"><a href="#实践原则" class="headerlink" title="实践原则"></a>实践原则</h4><ol><li><p>产出物管理</p><p>对每次构建的产出物进行管理，便于随时对历史构建版本进行部署，便捷地为测试和审计提供支持。</p></li><li><p>产出物和配置分离</p><p>实现一次构建，多环境部署的必要条件。</p></li><li><p>自动化测试和部署</p><p>部署流水线保证质量的关键因素，同时减少团队测试压力，快速反馈。</p></li><li><p>部署流水线的持续演进</p><p>持续的根据自身需求进行改进，探索符合团队的部署流水线。</p></li><li><p>制定开发规范，所有开发人员遵循该规范</p><p>规范比如是，</p><ol><li>遵循六部提交法</li><li>频繁提交</li><li>小步提交</li><li>提交完整代码</li><li>TDD（Test Driven Development，测试驱动开发）</li></ol></li><li><p>次级构建</p><p>在有性能瓶颈时，可以通过次级构建来提升流水线性能，保证反馈速度。</p></li></ol><h3 id="实践四：分支策略"><a href="#实践四：分支策略" class="headerlink" title="实践四：分支策略"></a>实践四：分支策略</h3><p>分支策略对于开发，构建和部署的影响尤其深远，一个好的分支可以让整个软件生命周期运转顺畅，相反则会严重的阻碍项目进展，甚至导致交付失败。分支策略选择不恰当，往往会导致分支管理混乱，最终导致团队消耗大量精力在分支管理上，甚至某些分支因为无法进行合并而不得不放弃。</p><h4 id="分支策略选择的三个影响因素"><a href="#分支策略选择的三个影响因素" class="headerlink" title="分支策略选择的三个影响因素"></a>分支策略选择的三个影响因素</h4><p>然而分支策略的选择也并不容易。不同团队，不同项目，分支策略不尽相同。甚至同一个团队，同一个项目，在不同时期也可能选择不同的分支策略。如何选择适合DevOps实践落地的分支策略？主要需要关注3个点。</p><ol><li><p>发布频率（时间）</p><p>DevOps强调快速发布，更快地把新特性带给用户。当然这里的快是相对于同类型产品来说，不同类型产品对于发布频率有各自的考量。比如互联网产品，需要非常快速的迭代。但传统行业如机械控制软件，强调稳定，发布频率必然会低上不少。当然发布频率更快也意味着发布时间更容易掌控，这对于软件开发也尤为重要。</p></li><li><p>每次发布的特性数量（特性）</p><p>DevOps实践的目的是更快地交付特性，因此每次能够发布多少特性的数量也尤为重要。团队需要对发布频率和每次发布的特性数量进行权衡。</p></li><li><p>如何保证发布质量（质量）</p><p>质量是一切的根本，是软件的基石。DevOps实践在加速团队发布频率和特性数量的时候，也必须要考虑质量。当然，很多DevOps实践就是为了保障质量，比如自动化测试，建立流水线快速反馈等等。</p></li></ol><p>团队需要在以上三个点（发布频率，特性数量，发布质量）中进行权衡。由此选择适合自身的发布策略，从而对应的选择分支策略。</p><h4 id="发布策略"><a href="#发布策略" class="headerlink" title="发布策略"></a>发布策略</h4><ol><li><p>项目制</p><p>三个影响因素中选择了<code>特性数量</code>和<code>发布质量</code>。</p><p>最直接的一种方式，因为满足业务需求是软件的根本目标，因此确定满足业务目标需要的特性数量。其次明确质量要求。而发布频率（时间）则是可以商量的。正是因为如此，这种发布策略很容易被延期，因为特性数量的不断变更，变更进而引出更多的质量问题，最终导致发布延迟。</p><p>通常也会创建一个项目组来攻坚，因此也称为项目制的发布策略。</p></li><li><p>发布火车</p><p>三个影响因素中选择了<code>发布频率</code>和<code>特性数量</code>。</p><p>由于多个团队相互依赖，不得不确定发布频率（时间）。发布频率必须是固定的，否则会造成连锁反应。当然如果发布时的特性无法正常交付，也会导致被依赖方的功能难以上线，同样造成连锁反应。这种发布策略的问题主要在于多个团队之间的沟通，因为依赖较多且复杂，沟通成本会随着团队数量的增加和功能的复杂性不断攀升。</p><p>由于一个个的发布就像火车发车一样，因此称为发布火车。</p></li><li><p>城际快线</p><p>三个影响因素中选择了<code>发布频率</code>和<code>发布质量</code>。</p><p>一到发布窗口便进行发布，不对每次发布的特性数量进行要求，只要满足质量要求，都可以进行发布。这种发布模式强调发布频率，因此每次发布的功能往往比较少，处理依赖也会比较容易。由于快速发布，因此会出现部分没有完成的特性被发布，因此需要通过feature toggle或者其他手段对这部分代码进行处理。</p><p>每次发布窗口就像城际列车一样，要搭乘哪一列由乘客（团队）自己决定，搭乘则意味着特性会一同发布。因此这种发布策略被称为城际快线。</p></li></ol><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>从实践的角度来看，常见的分支策略有三种，</p><ol><li><p>主干开发，主干发布</p><p>在主干上直接开发，所有开发也都直接提交并Push到主分支，发布也直接从主分支上进行构建和发布。</p><p>长期分支数量最少，因此消耗在管理分支上的支出是最少的，迎合了DevOps的核心思想——精益。</p><p>这种分支策略，常见的分支模型有Trunck Based<sup>[2]</sup>，其中采用这种思想的一个更为出名的叫法是Github Flow<sup>[3]</sup>。</p></li><li><p>主干开发，分支发布</p><p>有时候团队不得不长期维护一个或多个发布分支，所以不得不创建单独的分支进行发布，并由专人进行发布后的维护。</p><p>长期分支数量一定是至少两条，有时候甚至更多。为了处理这些分支，团队不得不花费更多的时间，而且分支越多所需的时间也越长。</p><p>本质上，由于开发还是在主干上，所以分支模型上来说基本还是和<code>主干开发，主干发布</code>没有太多区别。唯一的区别就是需要维护更多的分支，不过由于都是发布分支，并不存在大量的新功能的开发，所以不需要频繁发布。</p></li><li><p>分支开发，主干发布</p><p>为了保证主分支的绝对稳定，或者多个团队需要同时工作在一个产品上。那这种分支模型就可以登场了。</p><p>长期分支的数量也往往比较多，同样会有大量分支管理的投入。如果分支长期不合入主干，那到最后进行合并时，可能会是灾难性的。</p><p>代表性的分支模型便是Git Flow<sup>[4]</sup>了，这种模型的问题也非常明显，就是分支管理非常耗时，甚至无法管理，对此团队需要投入更多精力。</p></li></ol><h3 id="实践五：自动化测试"><a href="#实践五：自动化测试" class="headerlink" title="实践五：自动化测试"></a>实践五：自动化测试</h3><p>DevOps实践中尤为重要的一部分，有多个优势：</p><ol><li><p>减少失误率，提高准确性</p><p>机器执行，弥补人为执行的不确定性。保证零失误。</p></li><li><p>节约时间和成本</p><p>人工测试成本高昂，自动化测试可以替代大部分的人工测试。</p></li><li><p>提升测试覆盖率</p><p>人工测试难以全面覆盖，而自动化测试可以通过编写更多的测试用例，使其覆盖更加全面。</p></li><li><p>弥补手工测试的缺陷</p><p>有些场景手工测试难以覆盖，比如模拟多用户同时登陆。</p></li><li><p>快速反馈</p><p>自动化测试速度比人工测试快很多，便于团队更快拿到变更的反馈。</p></li><li><p>提高团队士气</p><p>每次提交都自动化的运行多个测试，经过完善的自动化测试验证后，往往会让团队更有信心。</p></li></ol><p>实施自动化测试可以遵循测试金字塔，根据不同层级提供不同类型和数量的自动化测试。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpobiwmwqbj307o069acd.jpg" alt="image-20210418233309098"></p><p>具体到微服务架构中，测试金字塔可以被具体化为，</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpobkh16wzj30c1081adi.jpg" alt="image-20210418233442226"></p><h3 id="实践六：配置管理"><a href="#实践六：配置管理" class="headerlink" title="实践六：配置管理"></a>实践六：配置管理</h3><p>发布频率提高，整个团队的活力都得到了激发，一个团队需要管理的产品也越来越复杂。因此对于配置的管理就变得越来越复杂，如何有效地对配置进行管理显得尤为重要。</p><p>配置管理包括了软件的方方面面，从软件的需求被定义开始，一直到部署发布。简单来说软件生命周期中的配置包括以下四类：</p><ol><li>需求</li><li>源码</li><li>软件包</li><li>环境配置</li></ol><p>如何管理这些软件配置，需要遵循以下原则：</p><ol><li><p>版本管理</p><p>对所有的配置信息进行版本管理。</p></li><li><p>唯一受信源</p><p>团队对于同一个配置仅有一个受信源，不存在多个。保证任何情况下，所有人获取的都是一样的配置。</p></li><li><p>标准化与自动化</p><p>所有的配置操作（分支策略，源码目录等）都有标准，便于管理和自动化。最终实现自动化的创建基线，管理和记录软件项目的里程碑。</p></li></ol><p>结合配置管理的四类配置，以及原则，可以归纳出下图：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprn5x98d3j30wm0ewav9.jpg" alt="image-20210421203140361" style="zoom:50%;" /><h3 id="实践七：发布管理"><a href="#实践七：发布管理" class="headerlink" title="实践七：发布管理"></a>实践七：发布管理</h3><p>为了支持更快速地发布，降低发布的风险，可以根据情况采用一些发布方法。</p><ol><li><p>蓝绿部署</p><p>两套环境，验证后进行切换，并且旧环境还可以作为备份，随时进行恢复。</p><p>缺点就是费资源。</p></li><li><p>滚动部署</p><p>逐一地替换掉部署的节点，直到全部替换完成。</p><p>缺点就是无法快速进行恢复。</p></li><li><p>金丝雀发布/灰度发布</p><p>按比例的替换掉节点，根据反馈来逐步提高替换节点的数量。如果反馈较好，则可以继续扩大部署，如果反应不够好，可以及时进行修改，甚至取消发布。</p></li><li><p>暗部署</p><p>在客户不知情的时候，让客户参与部署环境的测试。比如克隆客户的请求，或者直接将客户请求导入到新的处理器上。</p></li></ol><h3 id="实践八：运营支持"><a href="#实践八：运营支持" class="headerlink" title="实践八：运营支持"></a>实践八：运营支持</h3><p>监控可以给运营提供支持，从而反哺业务需求决策，最终形成DevOps实践闭环。</p><p>DevOps实践中，监控可以从三类下手，</p><ol><li><p>资源监测</p></li><li><ol><li>服务器节点的拥堵状态</li><li>CPU负载</li><li>内存及外部存储使用状况</li></ol></li><li><p>应用监测</p></li><li><ol><li>健康检测，是否能正常提供服务</li><li>功能缺陷</li><li>连接数据库是否正常</li><li>是否超时</li><li>抛出异常和告警</li><li>是否及时进行扩容</li><li>…</li></ol></li><li><p>业务监测</p></li><li><ol><li>访问量</li><li>页面浏览数</li><li>转化率</li><li>订单量</li><li>交易额</li></ol></li></ol><p>如何衡量监控的优劣呢？</p><ol><li><p><em>正确性</em></p><p>数据与事实的一致性</p></li><li><p><em>全面性</em></p><p>数据信息是否足以支持团队做出决策</p></li><li><p><em>及时性</em></p><p>数据的发生到能够支持决策所需的处理时间足够短</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 乔梁. <em>持续交付2.0-业务引领的DevOps精要</em>. 人民邮电出版社, 2018.</p><p>[2] trunkbaseddevelopment. Trunk Based Development[EB/OL]. <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>. 2020-06-25</p><p>[3] Scott Chacon. Github Flow[EB/OL]. <a href="http://scottchacon.com/2011/08/31/github-flow.html">http://scottchacon.com/2011/08/31/github-flow.html</a>. 2020-06-25</p><p>[4] Vincent Driessen. A successful Git branching model[EB/OL]. <a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a>. 2020-06-25</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> agile </tag>
            
            <tag> devops </tag>
            
            <tag> waterfall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git仓库管理：Submodule</title>
      <link href="/2020/11/14/2020-11-14-git-cang-ku-guan-li-submodule/"/>
      <url>/2020/11/14/2020-11-14-git-cang-ku-guan-li-submodule/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>Repository依赖于其他Repository，需要同步代码，但通过copy-paste的方式却难以保持被依赖Repository代码的及时同步。</p><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>使用git来管理各种项目，日积月累，各种项目的Repositories混杂在一起，想要搜索某一个，如大海捞针一般，难以管理。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h3 id="Submodule-1"><a href="#Submodule-1" class="headerlink" title="Submodule[1]"></a>Submodule<sup>[1]</sup></h3><p>使用submodule，将多个相关的Repositories放到一起管理，可以有效的避免上述场景一和场景二的问题。</p><p>对于场景一，正是submodule设计的初衷。通过引入被依赖的Repositories，既能方便的更新被依赖的Repositories的源代码，同时项目间的commits也不会相互影响。</p><p>对于场景二，通过submodule，实现了将多个相关的Repositories合并到一起，虽然父Repository没有实质代码，仅仅为了囊括其他相关Repositories而存在。但这样多出来的一层，使得Repositories的管理不至于因为过于扁平而显得杂乱无章。</p><h1 id="Submodule常见使用场景"><a href="#Submodule常见使用场景" class="headerlink" title="Submodule常见使用场景"></a>Submodule常见使用场景</h1><h2 id="add-submodule"><a href="#add-submodule" class="headerlink" title="add submodule"></a>add submodule</h2><p>开始使用submodule的第一个需求，是引入submodule。</p><pre><code>cd &lt;path-to-repo&gt;git submodule add git@github.com:regress0/sub-repo.git</code></pre><p>引入成功后，也可以使用submodule的status指令来查看其状态。</p><pre><code>git submodule status</code></pre><h2 id="change-submodule"><a href="#change-submodule" class="headerlink" title="change submodule"></a>change submodule</h2><p>对submodule做了修改，首先是需要查看changes，使用git自带的命令就能看到所有的diff。</p><pre><code>git diff#使用submodule参数可以将submodule单独列出来git diff --submodule</code></pre><p>不过更好的方式还是使用可视化的工具，比如Intellij自带的git可视化工具，能够更直观的看到每个submodule的情况。</p><h2 id="push-submodule"><a href="#push-submodule" class="headerlink" title="push submodule"></a>push submodule</h2><p>需要push某个submodule的时候，需要cd到对应的目录中，然后进行push。</p><p>或者push主repo的时候，一起push所有submodule的commits，可以带上<code>--recurse-submodules=on-demand</code>，如果有submodule的commits push失败，那主repo的push也会被撤销。</p><pre><code>git push --recurse-submodules=on-demand</code></pre><h3 id="delete-submodule"><a href="#delete-submodule" class="headerlink" title="delete submodule"></a>delete submodule</h3><p>直接删除submodule文件即可。</p><pre><code>rm -rf &lt;submodule-folder&gt;</code></pre><h3 id="clone带有submodule的repositroy"><a href="#clone带有submodule的repositroy" class="headerlink" title="clone带有submodule的repositroy"></a>clone带有submodule的repositroy</h3><p>直接clone主repo即可，所有的submodule都会自动clone下来。</p><pre><code>git clone &lt;repo&gt;</code></pre><h1 id="Submodule存在的一些问题"><a href="#Submodule存在的一些问题" class="headerlink" title="Submodule存在的一些问题"></a>Submodule存在的一些问题</h1><p>切换了分支后，某个submodule并未在这个分支中被引入，文件目录中仍然会有这个submodule，虽然不会有什么影响，但是确实会让人感到困惑。</p><p>尝试将子目录切换成submodule，也会因为已经存在该目录而失败，也需要将子目录先移除，再从外部引入来解决。</p><h1 id="Submodule总结"><a href="#Submodule总结" class="headerlink" title="Submodule总结"></a>Submodule总结</h1><p>submodule是可以用来解决上述的问题的，但由于引入了新的工具，也引入了新的复杂度，同时也增强了出现问题的概率。</p><p>出现的问题虽然都是小问题，但如果没有这些问题，git用起来会更顺手。</p><p>关于是否要使用Submodule还是只能基于当前的上下文，做出权衡。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Git. Git工具-子模块[EB/OL]. <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97#_git_submodules">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97#_git_submodules</a> , 2020-11-14.</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支模型：概览</title>
      <link href="/2020/06/27/2020-06-27-branch-model-overview/"/>
      <url>/2020/06/27/2020-06-27-branch-model-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="1-版本管理工具"><a href="#1-版本管理工具" class="headerlink" title="1. 版本管理工具"></a>1. 版本管理工具</h2><blockquote><p>工欲善其事，必先利其器。 ——《论语·卫灵公》</p></blockquote><p>版本管理，在软件开发中，特指对软件源码，以及相关文件的版本管理。</p><p>在软件开发过程中，需要用到形形色色的工具，版本管理工具绝对是无法绕开的一个，也是软件开发最开始就非常需要的工具。</p><h3 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h3><p>早在1972年，世界上第一款版本管理工具<strong>SCCS</strong>（Source Code Control System，源代码控制系统）遍开始流行<sup>[1]</sup>，提供最基础核心的源码多版本存储功能。</p><p>到1986年<strong>CVS</strong><sup>[1]</sup>（Concurrent Versions System，协作版本系统）发布。CVS提供将不同文件放到同一目录中，并提供层及目录，以及首次提供服务器和开发人员本地源码进行同步的功能，使其很快便流行开来，成为主流。</p><p>到2000年，<strong>Subversion</strong><sup>[2]</sup>（简称SVN）的发布，旨在替代CVS，成为新世纪的王者。SVN的众多新特性，比如全局统一的版本号，原子提交，提交可以记录重命名、复制、删除，极小的分支开销等等，使得其迅速替代CVS，一直流行到2010年代，甚至一直到现在（2020年）都还有不少项目仍在使用。</p><p>以上版本控制工具，除SCCS是仅用于本地开发以外，CVS和SVN因为存在一个中央服务器来存储所有的源码和文件，被称为<strong>CVC</strong>（Centralized Version Control，集中式版本控制）。与之对应的，<strong>DVC</strong>（Distributed Version Control，分布式版本控制），即不需要一个专门的中央服务器来存储源码和文件。</p><p>最早的DVC，是1992年发布的<strong>Sun WorkShop TeamWare</strong><sup>[3]</sup>，不过仅作为Sun公司的内部版本管理工具。</p><p>2000年，<strong>BitKeeper</strong><sup>[4]</sup>诞生，借鉴了TeamWare。BitKeeper借助DVC天然具有的分支零消耗，无需与中央服务器通信便可以离线编辑等等优势，在市场上博得了一席之地。也在2000年到2005年间一直作为Linux内核源码的版本管理工具。并在2016年开源。</p><p>2005年，日后版本控制界真正的王者，如今占据软件开发市场半壁江山的<strong>Git</strong><sup>[6]</sup>诞生。Git的诞生是为了能够接替BitKeeper，成为Linux内核源码的版本管理工具。主要由于BitKeeper作为商业软件，用来管理Linux这样一款鼎鼎大名的开源操作系统，显得有些讽刺。于是乎Linux作者，Linus Torvalds花了10天时间完成了Git的第一个版本。而后面的发展也是超出了大家的预期，Git如今（2020年）已是绝对的王者。不管是源码托管服务商Github、GitLab，国内的Gitee，还是流行的商业软件如BitBucket，都基于Git开发。全球最著名的云服务提供商AWS和Azure提供的源码管理服务（AWS的Codecommit，Azure的Azure DevOps）也都是基于Git实现。由此可见，Git如今的火爆程度可见一斑。</p><h3 id="1-2-为什么要使用版本管理"><a href="#1-2-为什么要使用版本管理" class="headerlink" title="1.2 为什么要使用版本管理"></a>1.2 为什么要使用版本管理</h3><p>理由很多，说几个重要的：</p><ol><li><p>多版本</p><p> 这是最原始的需求，也是版本管理工具提供的最核心的功能。使用版本管理工具，可以查看不同版本的源码，并切换到不同的版本。这让同一软件发布不同版本不再是一件难以完成的任务。对于不满意的修改也可以随时方便地撤销。</p></li><li><p>多分支</p><p> 使得同一软件的不同版本同时开发成为可能，发布不同版本也更加容易。除了不同版本的开发和发布以外，不同的开发目的也可以通过分支来区别，比如developer分支用于开发，master分支用于发布，feature分支用于某一特性的开发。这些不同的分支让越来越复杂的软件开发变得更加井井有条。</p></li><li><p>协同合作</p><p> 如今的软件开发越发复杂，几乎一定是团队协作完成。在多人合作的场景下，同时编辑一个文档在所难免，但同时编辑无法避免会带来冲突。最简单的避免冲突的方法就是编辑前通知其他也可能编辑该文件的伙伴先不要进行编辑，必须等你编辑完成后才能对该文件进行编辑。而有了版本管理，通知的事情大可以交给版本管理软件去完成。另外还可能存在完成文档修改后出现问题，版本管理也能快速帮你回退到之前的文档版本，帮助你定位或者快速修复问题。</p></li></ol><h3 id="CVC和DVC"><a href="#CVC和DVC" class="headerlink" title="CVC和DVC"></a>CVC和DVC</h3><h4 id="CVC（Centralized-Version-Control，集中式版本控制）"><a href="#CVC（Centralized-Version-Control，集中式版本控制）" class="headerlink" title="CVC（Centralized Version Control，集中式版本控制）"></a>CVC（Centralized Version Control，集中式版本控制）</h4><p>上文例举了一些典型的CVC和DVC工具，其中CVC的优劣都很明显，其中优势：</p><ol><li>中心节点对用户进行认证和授权，可以精细控制指定用户对于指定文件的权限。</li><li>中心节点通过对文件加锁，避免多人同时修改同一文件后进行合并而产生冲突。</li><li>开发进行修改时仅需要下载需要的部分文件，而不是整个项目。</li></ol><p>劣势：</p><ol><li>执行操作的速度慢，因为需要和中心节点进行通信，甚至还需要先解决冲突。</li><li>多人同时修改相同文件需要等待解锁。</li><li>出错后难以恢复，因为很难有完整副本。</li><li>必须联网才能使用。</li></ol><p>常用的CVC软件：</p><ol><li>CVS</li><li>Subversion</li></ol><h4 id="DVC（Distributed-Version-Control，分布式版本控制）"><a href="#DVC（Distributed-Version-Control，分布式版本控制）" class="headerlink" title="DVC（Distributed Version Control，分布式版本控制）"></a>DVC（Distributed Version Control，分布式版本控制）</h4><p>相较于CVC，DVC没有中心节点。开发将完整的仓库以及历史提交均保存到本地。任何对仓库的操作都是直接在本地进行操作。这一特点带给了DVC天然的优势：</p><ol><li>对仓库的操作速度很快，因为均为本地操作。</li><li>多人操作同一文件时无需等待锁。</li><li>可以离线使用</li><li>服务端出错后通过分布的任何一个仓库可以较好的恢复数据</li></ol><p>劣势：</p><ol><li>难以进行目录和文件级别的权限控制</li><li>合并时很可能需要解决冲突</li></ol><p>常用的DVC软件：</p><ol><li>Git</li><li>Mercurial</li></ol><p>如今这个提倡小而快的时代，DVC更加受欢迎。多人协同工作，而无需担心不能同时修改相同的文件，也无需管理笨重的中心服务器，或是处理繁琐的权限控制。更重要的是，敏捷和DevOps思想的持续火热，CICD（Continuous Integration &amp; Continuous Delivery）和Pipeline几乎成为团队必备的实践，而这样的实践所依赖的频繁的分支操作，DVC也更加适合。而DVC的众多软件中，Git无疑是当下最被频繁使用的一个。</p><h2 id="2-Git使用场景"><a href="#2-Git使用场景" class="headerlink" title="2. Git使用场景"></a>2. Git使用场景</h2><p>Git作为最火热的版本管理工具，被极为广泛的使用。简单如个人的小插件开发，两三个人的小应用开发，复杂如几十人的大型软件工程项目，都有它的身影。在这些不同的使用场景下，Git的使用方法也完全不同。</p><h3 id="2-1-单独开发"><a href="#2-1-单独开发" class="headerlink" title="2.1 单独开发"></a>2.1 单独开发</h3><p>一个人开发，最简单的Git使用场景，仅仅需要最基础的功能：</p><ol><li>代码的多版本储存（可以方便的切换到任意版本）</li></ol><h3 id="2-2-三个人的小团队"><a href="#2-2-三个人的小团队" class="headerlink" title="2.2 三个人的小团队"></a>2.2 三个人的小团队</h3><p>情况开始变得复杂，少量的协作出现。需要的功能点也更多：</p><ol><li>代码的多版本储存</li><li>简单的多分支（不同的人工作在不同的分支）</li><li>偶尔的冲突</li></ol><h3 id="2-3-十几个人的敏捷团队"><a href="#2-3-十几个人的敏捷团队" class="headerlink" title="2.3 十几个人的敏捷团队"></a>2.3 十几个人的敏捷团队</h3><p>十几个人同时工作在一个代码库上，大量的协作出现，甚至会出现大量的分支：</p><ol><li>代码的多版本储存</li><li>复杂的多分支</li><li>较多的冲突</li></ol><h3 id="2-4-数十上百人的大型团队"><a href="#2-4-数十上百人的大型团队" class="headerlink" title="2.4 数十上百人的大型团队"></a>2.4 数十上百人的大型团队</h3><p>通常会同时工作在多个版本，不同团队负责不同的版本。这样的规模的团队，已经不适合使用Git了，更好的方式是拆分，同时工作在一个代码库会显得非常笨重和难以维护。这个时候对于Git的功能点需求，其实并没有变得更多，只是对于分支的使用会变得复杂。此时的需求主要是：</p><ol><li>代码的多版本储存</li><li>复杂的多分支</li><li>大量的冲突</li></ol><h2 id="3-Git分支模型"><a href="#3-Git分支模型" class="headerlink" title="3. Git分支模型"></a>3. Git分支模型</h2><p>使用Git的过程中，随着团队规模的扩大，代码管理越来越复杂，而要做好代码管理，最重要的就是要做好分支的管理。因为现在的开发过程中必然需要处理CICD和多环境，紧急修复Bug，解决冲突合并代码，多Feature同步开发等等这样的情况。一条分支无法满足多人同时工作的需求，同一时间内同一个软件项目一定需要存在不同的状态，而多分支就可以满足这个需求。那如何设计和管理分支？如何更好的进行多人协同开发，更好的处理多版本发布？这时就需要一个好的分支使用方案，或者说是需要一个好的分支模型。市面上已经有很多很成熟的分支模型。</p><h3 id="3-1-Git-Flow-6"><a href="#3-1-Git-Flow-6" class="headerlink" title="3.1 Git Flow[6]"></a>3.1 Git Flow<sup>[6]</sup></h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85pazb7kj30u013sq9j.jpg" alt="git flow" style="zoom:67%;" /><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>2010年提出的Git分支模型，也是最早开始流行的Git分支模型。</p><p><strong>两条长期分支</strong></p><ol><li><p>master</p><p>最核心的分支，与当前线上的版本始终保持一致。</p></li><li><p>develop</p><p>开发分支，与当前已经开发完成的feature保持一致。</p></li></ol><p><strong>三种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，开发完成后，就会删除。</p></li><li><p>release（多条并存）</p><p>发布版本时使用的分支，一次发布对应一条，发布完成后，就会删除。</p></li><li><p>hotfix（多条并存）</p><p>紧急修复版本时使用的分支，一次紧急修复对应一条，修复完成后，就会删除。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从develop分支签出新的feature分支。</li><li>开发完成，部署并通过dev环境中的测试后，将feature分支合并回develop分支，然后删除feature分支。</li></ol><p><strong>部署流程</strong></p><ol><li>新代码merge到develop分支后，自动将develop分支部署到dev环境中，进行测试。（与开发流程中的步骤重叠）</li><li>在dev环境中测试通过后，将同一个构建物部署到qa，进行测试。</li><li>通过测试后，即完成除发布以外的所有部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>从develop分支签出新的release分支。</li><li>发布过程中的代码修改（可能是临时修复问题）。</li><li>将release分支合并到develop分支，以合并在release分支上进行的代码修改。</li><li>在release分支的发布准备工作完成后，将release分支合并到master分支，并打上版本tag，发布到pre-prod环境中，进行测试。</li><li>在pre-prod环境中测试完成后，将统一构建物部署到prod环境，并进行测试。</li><li>在prod环境中测试通过后，将release分支合并到develop分支。</li><li>删除release分支，完成发布。</li></ol><p><strong>紧急修复流程</strong></p><ol><li>从master签出新的hotfix分支。</li><li>修复完成后，将hotfix分支合并到master分支，打上版本tag，进行发布，同时将hotfix分支合并到develop分支。</li><li>将hotfix分支删除。</li></ol><h3 id="3-2-Github-Flow-7"><a href="#3-2-Github-Flow-7" class="headerlink" title="3.2 Github Flow[7]"></a>3.2 Github Flow<sup>[7]</sup></h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85pdqffpj31gi0hujt7.jpg" alt="github flow" style="zoom:67%;" /><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>2011年，由代码托管服务提供商Github提出的Git分支模型，广泛运用于开源项目。</p><p><strong>一条长期分支</strong></p><ol><li><p>master</p><p>唯一的长期分支，团队会尽量保证该分支一直处于可发布的状态。</p></li></ol><p><strong>一种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，开发完成，合并到master分支后就会被删除。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-1"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-1" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从master分支签出新的feature分支。</li><li>开发完成后，创建PR（Pull Request，合并请求），</li><li>PR通过团队审核，并通过全部测试后，将feature分支合并回master分支，然后删除feature分支。</li></ol><p><strong>部署流程</strong></p><ol><li>新代码merge到master分支后，自动将master分支部署到dev环境中，进行测试。（与开发流程中的步骤重叠）</li><li>在dev环境中测试通过后，将同一个构建物部署到qa，进行测试。</li><li>通过测试后，即完成除发布以外的所有部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>保证将要发布的master分支代码已经通过了除dev和qa环境的所有测试。</li><li>将同一构建物部署到pre-prod环境中，进行测试。</li><li>测试通过后，将统一构建物部署到prod环境，进行测试。</li><li>打上tag，完成发布。</li></ol><p><strong>紧急修复流程</strong></p><p>与开发流程一致。</p><h3 id="3-3-Trunk-Based-8"><a href="#3-3-Trunk-Based-8" class="headerlink" title="3.3 Trunk Based[8]"></a>3.3 Trunk Based<sup>[8]</sup></h3><p>Trunk Based有两种具体的分支模型，第一种：<strong>Trunk-Based Development For Smaller Teams</strong>，另外一种Trunk Based：<strong>Scaled Trunk-Based Development</strong>。</p><h4 id="3-3-1-Trunk-Based-Development-For-Smaller-Teams"><a href="#3-3-1-Trunk-Based-Development-For-Smaller-Teams" class="headerlink" title="3.3.1 Trunk-Based Development For Smaller Teams"></a>3.3.1 Trunk-Based Development For Smaller Teams</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85pcrwwoj31540hw775.jpg" alt="trunk based - smaller team" style="zoom:50%;" /><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p><strong>一条长期分支</strong></p><ol><li><p>master(trunk)</p><p>唯一的长期分支，团队会尽量保证该分支一直处于可发布的状态。</p></li></ol><p><strong>一种特殊分支</strong></p><ol><li><p>release（多条并存）</p><p>每次发布时创建的分支，仅用于发布，开发不能在分支上进行任何提交。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-2"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-2" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>在本地的master分支上进行开发。</li><li>开发完成后，通过git push命令将本地master合并到远程的master分支，合并前会自动进行build（包括单元测试）。</li><li>合并后进行测试（理想状态下是完全的自动化测试，不够理想的状态是自动化测试+人工测试），保证本次合并的代码可以被发布，如果测试失败，需要重复1、2步骤，直到测试通过。</li></ol><p><strong>部署流程</strong></p><ol><li>新代码merge到master分支后，自动将master分支部署到dev环境中，进行测试。（与开发流程中的步骤重叠）</li><li>在dev环境中测试通过后，将同一个构建物部署到pre-prod，进行测试。</li><li>通过测试后，即完成除部署prod以外的所有部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>master分支的代码已经通过了除prod环境以外的所有环境的测试。</li><li>从master签出release分支，进行发布，同时打上tag。</li><li>发布成功后，删除release分支。</li></ol><p><strong>紧急修复流程</strong></p><p>与开发流程一致。</p><h4 id="3-3-2-Scaled-Trunk-Based-Development"><a href="#3-3-2-Scaled-Trunk-Based-Development" class="headerlink" title="3.3.2 Scaled Trunk-Based Development"></a>3.3.2 Scaled Trunk-Based Development</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85pahok9j31560k4n0d.jpg" alt="trunk based - scaled team" style="zoom:50%;" /><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p><strong>一条长期分支</strong></p><ol><li><p>master(trunk)</p><p>唯一的长期分支，团队会尽量保证该分支一直处于可发布的状态。</p></li></ol><p><strong>两种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，开发完成，合并到master分支后就会被删除。</p></li><li><p>release（多条并存）</p><p>每次发布时创建的分支，仅用于发布，开发不能在分支上进行任何提交。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-3"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-3" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从master分支签出新的feature分支。</li><li>开发完成后，创建PR（Pull Request，合并请求）。</li><li>PR通过团队审核，并通过全部测试后，将feature分支合并回master分支，然后删除feature分支。</li></ol><p><strong>部署流程</strong></p><ol><li>将master部署到dev环境，进行测试。</li><li>测试通过后，将同一产出物，部署到qa环境，进行测试。</li><li>测试通过后，完成除发布以外的部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>master分支的代码已经通过了除prod环境以外的所有环境的测试。</li><li>从master签出release分支，发布到pre-prod环境，进行测试。</li><li>测试通过后，发布到prod环境，进行测试。</li><li>测试通过，删除release分支，完成发布。</li></ol><p><strong>紧急修复流程</strong></p><p>与开发流程一致。</p><h3 id="3-4-GitLab-Flow-9"><a href="#3-4-GitLab-Flow-9" class="headerlink" title="3.4 GitLab Flow[9]"></a>3.4 GitLab Flow<sup>[9]</sup></h3><p>Github flow有两种使用方法，针对需要做持续发布，且不存在多版本共存的项目，使用<strong>环境分支(Environment Branches)</strong>，针对需要发布不同版本的项目，使用<strong>发布分支(Reelase Branches)</strong>。</p><h4 id="3-4-1-环境分支模式"><a href="#3-4-1-环境分支模式" class="headerlink" title="3.4.1 环境分支模式"></a>3.4.1 环境分支模式</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85pbv139j30oe0qgdh1.jpg" alt="gitlab flow - environment branches" style="zoom:50%;" /><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p><strong>多条长期分支</strong></p><ol><li><p>master</p><p>开发分支，保持代码最新。并且用于部署到开发环境。</p></li><li><p>environment（多条并存）</p><p>根据情况，创建多条环境分支，比如pre-prod和prod分支。各个环境分支用于部署对应的环境。其中prod分支用于发布到产品环境。</p></li></ol><p><strong>一种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，开发完成，合并到master分支后就会被删除。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-4"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-4" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从master分支签出新的feature分支。</li><li>开发完成后，创建MR（Merge Request，合并请求）。</li><li>MR通过团队审核，自动部署到dev环境，通过全部自动测试后，将feature分支合并回master分支，然后删除feature分支。</li></ol><p><strong>部署流程</strong></p><ol><li>MR通过后，自动部署到dev环境，通过全部自动测试后，将feature分支合并回master分支，然后删除feature分支。（与开发流程中的步骤重叠）。</li><li>将dev分支merge到qa分支上，触发qa的CICD进行部署，并进行测试。</li><li>测试通过后，完成除发布以外的部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>将pre-prod分支merge到prod分支上，触发prod的CICD。</li><li>部署到prod后进行测试，通过全部测试后，部署完成。</li></ol><p><strong>紧急修复流程</strong></p><ol><li>从master分支签出新的hotfix分支。</li><li>开发完成后，创建MR（Merge Request，合并请求）。</li><li>MR通过团队审核，并通过全部测试后，将hotfix分支合并回master分支。</li><li>经过部署和发布流程，发布成功后，删除hotfix分支。</li></ol><h4 id="3-4-2-发布分支模式"><a href="#3-4-2-发布分支模式" class="headerlink" title="3.4.2 发布分支模式"></a>3.4.2 发布分支模式</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85p96qf9j30nw0vg75g.jpg" alt="gitlab flow - release branches" style="zoom:50%;" /><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p><strong>多条长期分支</strong></p><ol><li><p>master</p><p>开发分支，保持代码最新。并且用于部署到开发环境。</p></li><li><p>release（多条并存）</p><p>为每个稳定的发布分支创建独立的发布分支。</p></li></ol><p><strong>一种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，开发完成，合并到master分支后就会被删除。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-5"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-5" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从master分支签出新的feature分支。</li><li>开发完成后，创建MR（Merge Request，合并请求）。</li><li>MR通过团队审核，自动部署到dev环境，通过全部自动测试后，将feature分支合并回master分支，然后删除feature分支。</li></ol><p><strong>部署流程</strong></p><ol><li>MR通过团队审核，自动部署到dev环境，进行测试。</li><li>测试通过后，部署到qa环境，进行测试。</li><li>测试通过后，完成除发布外的所有部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>从master签出release分支，打上tag，准备发布。</li><li>构建release分支并部署到pre-prod环境中，进行测试。</li><li>测试通过后，部署到prod环境，进行测试。</li><li>测试通过后，发布完成。</li></ol><p><strong>紧急修复流程</strong></p><ol><li>从master分支签出新的hotfix分支。</li><li>开发完成后，创建MR（Merge Request，合并请求）。</li><li>MR通过团队审核，并通过全部测试后，将hotfix分支合并回master分支。</li><li>release分支cherry-pick在hotfix分支上的提交，并重新发布。</li><li>发布成功后，删除hotfix分支。</li></ol><h3 id="3-4-AnoFlow-10"><a href="#3-4-AnoFlow-10" class="headerlink" title="3.4 AnoFlow[10]"></a>3.4 AnoFlow<sup>[10]</sup></h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85p9xu3kj30wa0e8q4t.jpg" alt="anoflow" style="zoom:50%;" /><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p><strong>一条长期分支</strong></p><ol><li><p>master</p><p>主干分支，用于保持和线上环境的一致性。</p></li></ol><p><strong>三种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，发布完成后会被删除。</p></li><li><p>release（多条并存）</p><p>用于发布的分支，一次发布对应一个分支。</p></li><li><p>hotfix（多条并存）</p><p>用于紧急的bug修复，一次bug修复，对应一个分支。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-6"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-6" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从master分支签出新的feature分支。</li><li>代码开发完成后，将分支部署到dev环境，进行测试。</li><li>测试通过后，完成开发。</li></ol><p><strong>部署流程</strong></p><ol><li>将feature分支部署到dev环境，进行测试。</li><li>测试通过后，部署到qa环境，进行测试。</li><li>测试通过后，完成除发布外的所有部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>从master签出release分支，将需要发布的feature branches合并到release分支。</li><li>部署到pre-prod环境进行测试。</li><li>测试通过后，部署到prod环境，进行测试。</li><li>测试通过后，将release分支merge到master，并打上tag。</li><li>删除release和对应的feature branches后，完成发布。</li></ol><p><strong>紧急修复流程</strong></p><ol><li>从master分支签出新的hotfix分支，修复bug后发布到pre-prod进行测试。</li><li>测试通过后，发布到prod进行测试。</li><li>通过全部测试后，将hotfix分支合并回master分支，并打上tag。</li><li>删除hotfix分支，完成发布。</li></ol><h3 id="3-5-OneFlow-11"><a href="#3-5-OneFlow-11" class="headerlink" title="3.5 OneFlow[11]"></a>3.5 OneFlow<sup>[11]</sup></h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg85peipocj30tc0n00ui.jpg" alt="one flow" style="zoom:50%;" /><h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><p><strong>两条长期分支</strong></p><ol><li><p>develop</p><p>开发分支，与开发中的最新代码保持一致。</p></li><li><p>master</p><p>发布分支，用于与线上环境的代码保持一致。</p></li></ol><p><strong>三种短期分支</strong></p><ol><li><p>feature（多条并存）</p><p>开发功能的分支，一个功能对应一条，完成开发后删除。</p></li><li><p>release（多条并存）</p><p>用于发布的分支，一次发布对应一个分支，发布完成后删除。</p></li><li><p>hotfix（多条并存）</p><p>用于紧急的bug修复，一次bug修复，对应一个分支，完成bug修复后删除。</p></li></ol><h4 id="流程（假设有dev，qa，pre-prod，prod四个环境）-7"><a href="#流程（假设有dev，qa，pre-prod，prod四个环境）-7" class="headerlink" title="流程（假设有dev，qa，pre-prod，prod四个环境）"></a>流程（假设有dev，qa，pre-prod，prod四个环境）</h4><p><strong>开发流程</strong></p><ol><li>从develop分支签出新的feature分支。</li><li>代码开发完成后，将feature分支合并到develop分支，并部署到dev环境，进行测试。</li><li>测试通过后，完成开发，并删除feature分支。</li></ol><p><strong>部署流程</strong></p><ol><li>将develop分支部署到dev环境，进行测试。</li><li>测试通过后，部署到qa环境，进行测试。</li><li>测试通过后，完成除发布外的所有部署流程。</li></ol><p><strong>发布流程</strong></p><ol><li>从develop签出release分支，并部署到pre-prod环境进行测试。</li><li>测试通过后，部署到prod环境，进行测试。</li><li>测试通过后，将release分支merge到master，并打上tag。</li><li>删除release分支，完成发布。</li></ol><p><strong>紧急修复流程</strong></p><ol><li>从master分支签出新的hotfix分支，修复bug后发布到pre-prod进行测试。</li><li>测试通过后，发布到prod进行测试。</li><li>通过全部测试后，将hotfix分支合并回master分支以及develop分支，并打上tag。</li><li>删除hotfix分支，完成发布。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Wikipedia. 协作版本系统[EB/OL]. <a href="https://zh.wikipedia.org/wiki/%E5%8D%94%E4%BD%9C%E7%89%88%E6%9C%AC%E7%B3%BB%E7%B5%B1">https://zh.wikipedia.org/wiki/%E5%8D%94%E4%BD%9C%E7%89%88%E6%9C%AC%E7%B3%BB%E7%B5%B1</a>. 2020-06-23</p><p>[2] Wikipedia. Subversion[EB/OL]. <a href="https://zh.wikipedia.org/wiki/Subversion">https://zh.wikipedia.org/wiki/Subversion</a>. 2020-06-23</p><p>[3]Wikipedia. Sun WorkShop TeamWare[EB/OL]<a href="https://en.wikipedia.org/wiki/Sun_WorkShop_TeamWare">https://en.wikipedia.org/wiki/Sun_WorkShop_TeamWare</a>. 2020-06-23</p><p>[4] Wikipedia. Bitkeeper[EB/OL]. <a href="https://zh.wikipedia.org/wiki/BitKeeper">https://zh.wikipedia.org/wiki/BitKeeper</a>. 2020-06-23</p><p>[5] Wikipedia. Git[EB/OL]. <a href="https://zh.wikipedia.org/wiki/Git#%E7%89%88%E6%9C%AC">https://zh.wikipedia.org/wiki/Git#%E7%89%88%E6%9C%AC</a>. 2020-06-23</p><p>[6] Vincent Driessen. A successful Git branching model[EB/OL]. <a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a>. 2020-06-25</p><p>[7] Scott Chacon. Github Flow[EB/OL]. <a href="http://scottchacon.com/2011/08/31/github-flow.html">http://scottchacon.com/2011/08/31/github-flow.html</a>. 2020-06-25</p><p>[8] trunkbaseddevelopment. Trunk Based Development[EB/OL]. <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>. 2020-06-25</p><p>[9] Sytse Sijbrandij. Gitlab Flow[EB/OL]. <a href="https://about.gitlab.com/blog/2014/09/29/gitlab-flow/">https://about.gitlab.com/blog/2014/09/29/gitlab-flow/</a>. 2020-06-25</p><p>[10] segmentfault. 开发分支管理模型之阿里AoneFlow[EB/OL]. <a href="https://segmentfault.com/a/1190000016373314">https://segmentfault.com/a/1190000016373314</a>. 2020-06-25</p><p>[11] Adam Ruka. OneFlow – a Git branching model and workflow[EB/OL]. <a href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#variation-develop-master">https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#variation-develop-master</a>. 2020-06-25</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> branch_model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Certification - Solutions Architect Professional</title>
      <link href="/2020/06/19/2020-06-19-aws-solution-architect-professional/"/>
      <url>/2020/06/19/2020-06-19-aws-solution-architect-professional/</url>
      
        <content type="html"><![CDATA[<h2 id="1-AWS-Certification介绍"><a href="#1-AWS-Certification介绍" class="headerlink" title="1. AWS Certification介绍"></a>1. AWS Certification介绍</h2><h3 id="1-1-AWS-Certification体系"><a href="#1-1-AWS-Certification体系" class="headerlink" title="1.1 AWS Certification体系"></a>1.1 AWS Certification体系</h3><p>先上图<sup>[1]</sup>：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyisv4gxvj31gz0u04bh.jpg" alt="image-20200620094050140" style="zoom:50%;" /><p>AWS Certification体系分为两个部分，</p><ol><li>Professional，Associate和Foundational</li><li>Specialty</li></ol><p>第一部分从易到难，Foundational -&gt; Associate -&gt; Professional，从对AWS的基础了解一直到提供专业解决方案和落地部署能力的认证。</p><p>第二部分则没有划分难度，针对运用AWS解决不同领域问题的能力的认证。</p><p>不同的认证，也代表着不同的AWS能力。</p><p>对于Professional，Associate和Foundational的认证，无需从低到高的考试，可以直接参加Professional的认证。</p><h3 id="1-2-Solutions-Architect-Professional-SAP"><a href="#1-2-Solutions-Architect-Professional-SAP" class="headerlink" title="1.2 Solutions Architect Professional(SAP)"></a>1.2 Solutions Architect Professional(SAP)</h3><p>说到SAP，属于Professional的认证，但难度其实并没有想象中的大，我从业一年多，利用下班时间，准备了3个星期，最终是902分的成绩通过（总分1000）。这里来一道真题感受感受：</p><blockquote><p>A company runs a legacy system on a single m4.2xlarge Amazon EC2 instance with Amazon EBS2 storage. The EC2 instance runs both the web server and a self-managed Oracle database. A snapshot is made of the EBS volume every 12 hours, and an AMI was created from the fully configured EC2 instance.<br>A recent event that terminated the EC2 instance led to several hours of downtime. The application was successfully launched from the AMI, but the age of the<br>EBS snapshot and the repair of the database resulted in the loss of 8 hours of data. The system was also down for 4 hours while the Systems Operators manually performed these processes.<br>What architectural changes will minimize downtime and reduce the chance of lost data?</p><p>A. Create an Amazon CloudWatch alarm to automatically recover the instance. Create a script that will check and repair the database upon reboot. Subscribe the Operations team to the Amazon SNS message generated by the CloudWatch alarm.</p><p>B. Run the application on m4.xlarge EC2 instances behind an Elastic Load Balancer/Application Load Balancer. Run the EC2 instances in an Auto Scaling group across multiple Availability Zones with a minimum instance count of two. Migrate the database to an Amazon RDS Oracle Multi-AZ DB instance.</p><p>C. Run the application on m4.2xlarge EC2 instances behind an Elastic Load Balancer/Application Load Balancer. Run the EC2 instances in an Auto Scaling group across multiple Availability Zones with a minimum instance count of one. Migrate the database to an Amazon RDS Oracle Multi-AZ DB instance.</p><p>D. Increase the web server instance count to two m4.xlarge instances and use Amazon Route 53 round-robin load balancing to spread the load. Enable Route 53 health checks on the web servers. Migrate the database to an Amazon RDS Oracle Multi-AZ DB instance.</p></blockquote><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><ol><li><p>题量和考试时间</p><p>75题，180分钟。</p></li><li><p>试题类型</p><p>全部选择题，单选（4选1）和多选（5选2，6选3）。</p></li><li><p>试题特点</p><p>阅读量普遍较大，上面的例题算是中偏上的阅读量。没有准备的话，直接裸考，时间会很紧张。但准备得当，时间就不是问题。</p></li><li><p>证书有效期</p><p>3年。</p></li><li><p>考试费用</p><p>SAP的费用是300美元。第一次考没有优惠，3年到期后，更新证书，会有50%折扣。具体情况可以去<a href="https://aws.amazon.com/cn/certification/certification-prep/">AWS Certification网站</a>上看看</p></li></ol><h3 id="SAP有什么用"><a href="#SAP有什么用" class="headerlink" title="SAP有什么用"></a>SAP有什么用</h3><ol><li>认证的作用自然是证明你有作为AWS Solutions Architect的能力，对于不了解你的人，有这个权威的第三方认证，第一印象自然会好一些。至于SAP的含金量，至少还没有被玩坏，有总比没有好。</li><li>考证对于提升个人AWS能力，绝对是有帮助的。想要通过SAP，必须要相对系统的学习AWS的各种服务。考证就相当于结业考试了，结果固然重要，但过程对于个人的能力提升绝对还是有帮助的。</li></ol><h2 id="2-SAP考试准备"><a href="#2-SAP考试准备" class="headerlink" title="2. SAP考试准备"></a>2. SAP考试准备</h2><h3 id="2-1-了解考试情况"><a href="#2-1-了解考试情况" class="headerlink" title="2.1 了解考试情况"></a>2.1 了解考试情况</h3><p>上文已经介绍了很多SAP的考试情况，了解考试情况主要还是来自于AWS Certification官网。</p><p>可以了解考试指南，可以去<a href="https://aws.amazon.com/certification/certified-solutions-architect-professional/?nc1=h_ls">考试指南网站</a>。提供了最新的考试的细节信息。毕竟考试会不定期更新，了解最新的内容还是有必要。</p><p>可以了解考试的内容，可以去<a href="https://d1.awsstatic.com/training-and-certification/docs-sa-pro/AWS-Certified-Solutions-Architect-Professional_Exam-Guide.pdf">考试内容网站</a>。提供了最新的考试建议，尤其是重要的是，提供了考试的不同内容的占比。根据这个占比去调整自己的学习计划，也是非常重要的。</p><h3 id="2-2-学习考试内容"><a href="#2-2-学习考试内容" class="headerlink" title="2.2 学习考试内容"></a>2.2 学习考试内容</h3><p>学习考试内容，有两个很实用的建议：</p><ol><li>如果对AWS内容不太熟悉，一定需要一个可以用于实际操作的AWS账号。很多AWS服务只看介绍，很难搞懂。推荐<a href="https://linuxacademy.com/">LinuxAcademy</a>的学习教程，不仅有视频教程，还有免费的学习账号。注册费用小贵，酌情考虑。</li><li>务必要看一下真题，不然SAP的难度陡增，因为阅读量大，部分题的选项迷惑性较大。看真题可以用<a href="https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-professional/view/40/">ExamTopics</a>，这个网站是真的好，不仅免费，而且SAP的题库命中率奇高（考试中70%~80%的题都是原题）。SAP一定要把Topic 2的160题做完（实际有180题，但最后20题是重复的）。不过有个很大的问题，ExamTopics上的题大多数答案都不正确，这就要靠自己去识别正确答案了。每个人对那些有争议的题，都会有不同的看法。多看看题下面的讨论，可以帮助自己找到正确的答案。</li></ol><h3 id="2-3-报名考试"><a href="#2-3-报名考试" class="headerlink" title="2.3 报名考试"></a>2.3 报名考试</h3><p>同样的，在<a href="https://aws.amazon.com/cn/certification/certification-prep/">AWS Certification的网站</a>上，点击安排考试，注册登陆过后就可以报名了。</p><p>有几个点可以说一下：</p><ol><li>选择PSI或者Pearson VUE都一样，考试过程都是一样的，题目也都是连接远程服务器获取得来的，唯一不同的可能就是地址和考试环境吧，这个很难说谁好谁坏。</li><li>选择合适的时间和考试地点。时间上建议选择第一场，早一点人会少一些，可以避免交接时候的嘈杂，毕竟考试可能不是单间。地点计算好交通时间就好了，不要迟到。</li><li>报名考试需要VISA，Master这种能够支付USD的信用卡，任何储蓄卡和银联信用卡都用不了。没有准备好的话，可以提前准备好。</li></ol><h3 id="2-4-完成考试"><a href="#2-4-完成考试" class="headerlink" title="2.4 完成考试"></a>2.4 完成考试</h3><p>如果你已经按照上文的方式准备好了，考试当天需要注意几点：</p><ol><li>需要提前到场，留一些时间去做考试前的认证。官方会建议你提前15分钟，用于验证身份和录入信息，实际上这个过程顺利的话只需要5分钟不到。建议提前更久一点，因为提前到也可以提前考（有机位的话）。晚到的话，可能会影响你的考试，一定要避免这种风险。</li><li>另外，SAP考试时间是180分钟，时间很长，中途是绝对不允许离场的（离场即交卷），所以身体一定要准备好。</li></ol><p>SAP的考试内容分为3个部分：</p><ol><li>登入系统。工作人员会给你一个用户名密码，登入过后就可以考试考试了。</li><li>阅读考试注意事项。很简短，介绍一下考试内容，我也没太认真读。</li><li>开始考试（180分钟）。控制好时间就行了。AWS Certification的考试系统功能还是挺多的，有倒计时，可以标记，可以留下评论。</li><li>完成考试。提交答卷后，会立即给出结果，显示“pass”则为通过。</li><li>完成考试调查。完成考试后，有个简短的考试调查，这是最后一步了，完成后就可以回家了。</li></ol><h3 id="2-5-获得证书"><a href="#2-5-获得证书" class="headerlink" title="2.5 获得证书"></a>2.5 获得证书</h3><p>如果通过考试，证书会很快发送到你报名注册的邮箱，通常1到2天。</p><p>后续还会有成绩报告，通常需要3到5天。成绩报告会有分数，已经对于各个考察部分的评价。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] AWS. AWS Certification[EB/OL]. <a href="https://aws.amazon.com/cn/certification/?nc2=sb_ce_co">https://aws.amazon.com/cn/certification/?nc2=sb_ce_co</a> , 2020-06-19.</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aws </tag>
            
            <tag> cloud </tag>
            
            <tag> certification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Lambda CICD</title>
      <link href="/2019/09/22/2019-09-22-aws-lambda-cicd/"/>
      <url>/2019/09/22/2019-09-22-aws-lambda-cicd/</url>
      
        <content type="html"><![CDATA[<h2 id="Serverless简介"><a href="#Serverless简介" class="headerlink" title="Serverless简介"></a>Serverless简介</h2><p>AWS Lambda是Serverless（无服务）的一种实践，那什么是Serverless？</p><p>Serverless<sup>[1]</sup>目前并没有一个权威的定义。<br>Serverless的无服务是指，使用者无需知道服务是如何运行，只需要专注于业务代码的编写。<br>对于代码的管理，部署，以及弹性伸缩等功能均无需使用者关心。这就可以极大的解放使用者，<br>使其将更多的精力投入到业务代码的编写中。因此serverless的无服务是针对使用者来说的。</p><p>对于计算资源的使用方式的发展历程来看，Serverless自然是很年轻的代表。<br>最早期的计算服务要数单机计算资源共享，大家使用不同用户登录到同一台机器上，从而分享该机器的计算资源。<br>随着计算机的不断廉价，人人都可以拥有计算机，从此告别了共享一台机器的时代。<br>随着运算量的飞速扩张，单机无法满足需求，由此进入集群的时代，计算能力开始横向扩展。<br>而由于超强运算能力的集群成本高昂，分享集群计算资源的形式出现，自此IaaS，PaaS和SaaS开始占据主流。</p><p>IaaS(Infrastructure as a Service)提供最基础的计算能力，相当于提供给我们一台云端的计算机。<br>PaaS(Platform as a Service)则不只是提供一个计算机，同时还装好操作系统，以及管理和运行我们自己软件的设施。<br>SaaS(Service as a Service)则更进一步，直接针对我们的需求，提供给我们已经装好，直接能用的软件。</p><p>而Serverless提供给我们的类似于一个PaaS，它提供一个平台来运行我们自己的代码。<br>但这个平台中我们无需关心平台的性能，运行的所有细节均由平台负责。这一点上与普通的PaaS有着较大区别。<br>因此，某种程度来说，Serverless也像一种SaaS平台，提供的服务就是能接收你的代码，自动帮你编译打包执行。</p><h2 id="AWS-Lambda简介"><a href="#AWS-Lambda简介" class="headerlink" title="AWS Lambda简介"></a>AWS Lambda简介</h2><p>AWS Lambda是AWS的一个Serverless服务。非常低的运营成本和开发成本，同时价格也非常便宜。另外还有可弹性伸缩的计算能力。<br>而且在AWS云服务的生态圈中，Lambda可以和其他AWS服务配合，完成各种业务功能。</p><h2 id="CICD简介"><a href="#CICD简介" class="headerlink" title="CICD简介"></a>CICD简介</h2><p>编写代码是将业务过程描述成计算机能够识别的语言。即便给计算机的书写好了，也得知道如何印刷出版。<br>CICD(Continuous Integrate Continuous Delivery)大概就是定义印刷（编译打包）和出版（发布）的过程了。<br>我们通常会搭建自动化的CICD Pipeline，以便我们对业务代码进行更新后，可以非常简单可控的发布我们的新版本。</p><h2 id="AWS-Lambda的CICD设计"><a href="#AWS-Lambda的CICD设计" class="headerlink" title="AWS Lambda的CICD设计"></a>AWS Lambda的CICD设计</h2><p>AWS Lambda本身并没有提供适用性很强的CICD，因此为了能够方便的对Lambda代码进行修改，自己搭建Pipeline是必不可少的步骤。</p><p>CICD的设计本文会介绍两种。<br>一种是竟可能多的使用AWS Lambda提供的功能，本文称之为”方案一：环境独立的Lambda的CICD方案”。<br>另一种是使用部分AWS Lambda + 自定义的一部分定制化功能，本文称之为”方案二：环境共享的Lambda的CICD方案”。</p><h2 id="方案一：环境独立的Lambda的CICD方案"><a href="#方案一：环境独立的Lambda的CICD方案" class="headerlink" title="方案一：环境独立的Lambda的CICD方案"></a>方案一：环境独立的Lambda的CICD方案</h2><p>环境独立的Lambda指的是，为不同的运行环境创建各自的Lambda函数。<br>针对这种设计，CICD的设计图大致如下：</p><p><img src="https://i.loli.net/2019/10/08/AgI49BsMyZF8nGr.png" alt="image.png"></p><p>这里一共存在了3个环境，包括prod账号下的p环境，non-prod账号下创建的Dev和PreProd环境。<br>因此一共需要为这3个环境创建3个Lambda函数，同时也为这3个Lambda函数创建了对应的Cloudwatch log group来记录对应的Lambda函数执行日志。</p><p>CICD的设计也是围绕这几个Lambda函数展开，分为以下几个步骤：</p><ol><li><p>Build</p><p> 目的是生成能够发布到各个环境中的软件。<br> 为了保证发布到不同环境的软件能一致，Build过程应只有一次，<br> 从而避免因为Build环境发生变化而导致发布的软件不一致。</p><p> 该步骤过程如下：</p><p> 1.1 从Github上拉去代码源码，</p><p> 1.2 根据源码的Build方式，对源码进行Build，通常为编译或者打包。</p><p> 1.3 然后将打包完成的产出物存放到AWS Simple Storage Service(S3)的Bucket中（相当于一个仓库）。<br> 这里的S3为Prod账号下的S3，这样做的目的在于保证在Dev账号不工作的情况下，不会影响Prod环境的发布。<br> 因此与Prod环境强相关的资源都会放到Prod账号下。    </p></li><li><p>Deploy Dev</p><p> 该步骤过程如下：</p><p> 2.1 将Build阶段的产出物，根据其版本号，从S3上的产出物仓库中下载到执行Deploy的机器上。</p><p> 2.2 从S3的配置文件仓库中下载部署环境对应的配置文件。</p><p> 2.3 将配置文件嵌入到产出物。</p><p> 2.4 把产出物发布到Dev环境中的Lambda。</p></li><li><p>Deploy PreProd</p><p> 步骤与Deploy Dev类似：</p><p> 3.1 将Build阶段的产出物，根据其版本号，从S3上的产出物仓库中下载到执行Deploy的机器上。</p><p> 3.2 从S3的配置文件仓库中下载部署环境对应的配置文件。</p><p> 3.3 将配置文件嵌入到产出物。</p><p> 3.4 把产出物发布到PreProd环境中的Lambda。</p></li><li><p>Deploy Prod</p><p> 步骤与前两个Deploy步骤类似：</p><p> 3.1 将Build阶段的产出物，根据其版本号，从S3上的产出物仓库中下载到执行Deploy的机器上。</p><p> 3.2 从S3的配置文件仓库中下载部署环境对应的配置文件。</p><p> 3.3 将配置文件嵌入到产出物。</p><p> 3.4 把产出物发布到Prod环境中的Lambda。</p></li></ol><p>至此，完成了整个Lambda的发布。</p><h2 id="方案二：环境共享的Lambda的CICD方案"><a href="#方案二：环境共享的Lambda的CICD方案" class="headerlink" title="方案二：环境共享的Lambda的CICD方案"></a>方案二：环境共享的Lambda的CICD方案</h2><p>环境共享的Lambda指的是，不同的运行环境共享一个Lambda函数。<br>针对这种设计，CICD的设计图大致如下：</p><p><img src="https://i.loli.net/2019/10/08/CRrALitndSxEv4B.png" alt="image.png"></p><p>这里一共存在了3个环境，包括prod账号下的p环境，non-prod账号下创建的Dev和PreProd环境。<br>因为Dev和PreProd共享non-prod的Lambda，因此一共需要为这3个环境创建2个Lambda函数，同时也为这2个Lambda函数创建了对应的Cloudwatch log group来记录对应的Lambda函数执行日志。</p><p>CICD的设计也是围绕这2个Lambda函数展开，分为以下几个步骤：</p><ol><li><p>Build Non-Prod</p><p> 与方案一一样，目的是生成能够发布到各个环境中的软件。<br> 为了保证发布到不同环境的软件能一致，Build也只有一次（图中第二次并不生成新的产出物），<br> 从而避免因为Build环境发生变化而导致发布的软件不一致。</p><p> 该步骤过程如下：</p><p> 1.1 从Github上拉去代码源码。</p><p> 1.2 根据源码的Build方式，对源码进行Build，通常为编译或者打包。</p><p> 1.3 将编译或打包的产出物发布到Non-Prod的Lambda中，并使Lambda自动生成新版本。</p><p> 1.4 然后将打包完成的产出物存放到AWS Simple Storage Service(S3)的Bucket中（相当于一个仓库）。<br> 这里的S3为Prod账号下的S3，这样做的目的在于保证在Dev账号不工作的情况下，不会影响Prod环境的发布。<br> 因此与Prod环境强相关的资源都会放到Prod账号下。</p></li><li><p>Deploy Dev</p><p> 该步骤过程如下：</p><p> 2.1 更新Alias Dev到由Build Non-Prod过程产生的Lambda版本。</p></li><li><p>Deploy PreProd</p><p> 该步骤过程如下：</p><p> 3.1 更新Alias PreProd到由Build Non-Prod过程产生的Lambda版本。</p></li><li><p>Build Prod</p><p> 该步骤过程如下：</p><p> 2.1 将Build阶段的产出物，根据其版本号，从S3上的产出物仓库中下载到执行Deploy的机器上。</p><p> 2.2 把产出物发布到Prod账号中的Lambda，并使Lambda自动生成新的版本。</p></li><li><p>Deploy Prod</p><p> 该步骤过程如下：</p><p> 5.1 更新Alias Prod到由Build Prod过程产生的Lambda版本。</p></li></ol><h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><p>一个CICD方案通常需要考虑以下几点：</p><ol><li>是否能保证部署软件的一致性，即部署到不同环境的软件是否完全相同。</li><li>配置文件在部署时传入。</li><li>是否支持自定义的版本控制。</li><li>是否支持回滚。</li><li>部署操作是否简单，部署速度是否快速。</li><li>创建CICD相关的资源是否复杂，是否经济。</li></ol><p>针对以上几个点，简要分析了上述两个方案的优劣，如下表：</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 环境独立的Lambda</td><td>1. 只需要Build一次，保证产出物的一致</td><td>1. 需要自己维护Lambda函数版本</td></tr><tr><td></td><td>2. 配置文件在Build阶段加载，保证Lambda函数是纯函数</td><td>2. 部署操作涉及较多步骤，相对复杂（Build阶段需要严格的版本控制，Deploy阶段需要针对不同环境使用不同的配置文件）</td></tr><tr><td></td><td>3. 支持针对任意环境的版本回滚</td><td>3. 创建多个Lambda函数，维护更多的资源</td></tr><tr><td></td><td>4. 部署速度快</td><td></td></tr><tr><td>2. 环境共享的Lambda</td><td>1. 只需要Build一次，保证产出物的一致(第二次并非真正Build)</td><td>1. 配置文件由运行时去获取，既无法保证Lambda的纯函数性质，也会提高AWS的费用</td></tr><tr><td></td><td>2. 维护的资源更少，易于维护使用</td><td>2. 使用Lambda自带的版本控制，因而无法自定义版本号，而由于跨账号，因此无法将Non-Prod和Prod的Lambda版本对齐</td></tr><tr><td></td><td>3. 支持版本回滚</td><td>3. 回滚无法做到指定环境回滚，必须由低环境到高环境，即Dev到Prod</td></tr><tr><td></td><td>4. 部署操作非常简单（将Alias指向对应Lambda版本即可）</td><td></td></tr><tr><td></td><td>5. 部署速度极快</td><td></td></tr><tr><td></td><td>6. 环境共享Lambda，占用资源更少</td><td></td></tr></tbody></table><h1 id="实现CICD"><a href="#实现CICD" class="headerlink" title="实现CICD"></a>实现CICD</h1><p>使用Terraform创建Lambda的资源</p><p><img src="https://i.loli.net/2019/09/28/A7UYD1e6xarwiZ4.png" alt="terraform_module"></p><p>Lambda本身并只是一个函数，在真实环境中运行还是需要相关资源的配合。<br>上图简单概括了一个AWS中一个Lambda函数需要的相关资源。<br>当你用Terraform实现Lambda时，针对这些资源，均可以抽象出来对应的Terraform Module。</p><ol><li><p>Lambda Module</p><p> Lambda函数核心资源，用于实现对应的业务逻辑。<br> 创建Lambda资源时，并不关心具体的业务代码，因此使用空的代码即可。<br> 目的只是为业务代码创建一个Lambda运行环境。</p></li><li><p>Alias（仅方案二时需要）</p><p> 在环境共享Lambda的方案（方案二）中，我们需要创建一个Alias Module。<br> 该Module用于为不同环境创建对应的Alias，从而实现不同环境执行不同版本的Lambda。</p></li><li><p>IAM</p><p> IAM Module为Lambda创建一个IAM Role，并将Lambda需要的权限添加到该Role中。<br> 作为一个通用的Module，在Module中只应该添加一些通用的，所有的Lambda均需要的权限，比如访问Cloudwatch的权限。<br> 该Module将Role的ARN输出，以便于从外部添加定制化的权限给Lambda。</p></li><li><p>Cloudwatch</p><p> 该Module创建一个Cloudwatch log-group，用于记录Lambda的执行日志。</p></li><li><p>Trigger</p><p> 一个Lambda都有对应的触发器，可能是API-Gateway，可能是Cloudwatch或者SNS等等。<br> 因此Trigger Module就是用来创建触发器的资源。<br> 触发器往往都是已经存在的资源，并不会在该Module中创建。<br> 但是一些和Trigger Lambda相关的动作，需要Lambda端进行配置，比如配置权限。<br> 这些配置需要的资源则应该在Trigger Module中进行创建。</p></li></ol><h2 id="Ref-参考文献"><a href="#Ref-参考文献" class="headerlink" title="Ref 参考文献"></a><code>Ref</code> 参考文献</h2><p>[1] AWS Team. 从IaaS到FaaS——Serverless架构的前世今生[EB/OL]. <a href="https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/">https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</a>, 2019-09-28.</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aws </tag>
            
            <tag> lambda </tag>
            
            <tag> cicd </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/03/20/2018-03-20-guan-cha-zhe-mo-shi/"/>
      <url>/2018/03/20/2018-03-20-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="What-观察者模式的概念？"><a href="#What-观察者模式的概念？" class="headerlink" title="What 观察者模式的概念？"></a><code>What</code> 观察者模式的概念？</h2><p>简单的理解观察者模式的过程，就是被观察者发生变化，通知观察者做出相应的反应。<br>这个典型的解释就是观察者模式的Push模式，另外还有Pull模式。</p><h3 id="Push模式"><a href="#Push模式" class="headerlink" title="Push模式"></a>Push模式</h3><p>Push模式的类图如下：</p><p><img src="https://i.loli.net/2018/03/26/5ab8a7d9b971e.png" alt="观察者模式-Push">{:height=”400px” width=”600px”}</p><p>被观察的Subject中持有数据，当数据发生变化，会调用所有已注册的观察者(observers)的对应方法(doAction)。<br>Observer中定义了doAction方法，仅接受它需要的数据。</p><h3 id="Pull模式"><a href="#Pull模式" class="headerlink" title="Pull模式"></a>Pull模式</h3><p>Pull模式的类图如下：</p><p><img src="https://i.loli.net/2018/03/26/5ab8a82bbbd3e.png" alt="观察者模式-Pull">{:height=”400px” width=”900px”}</p><p>被观察的Subject中持有数据，当数据发生变化，会调用所有已注册的观察者(observers)的对应方法(doAction)。<br>但会将整个Subject传给doAction方法，从而由Observer来决定需要调用哪些数据（通过调用Subject提供的get方法来获取需要数据）。</p><h2 id="When-什么时候使用观察者模式？"><a href="#When-什么时候使用观察者模式？" class="headerlink" title="When 什么时候使用观察者模式？"></a><code>When</code> 什么时候使用观察者模式？</h2><p>简而言之，当一个数据的改变会引起多个地方发生变化，这个时候就可以使用观察者模式。</p><p>至于选择Push还是Pull，可以根据以下对比来自行选择</p><table><thead><tr><th align="center">方式</th><th align="left">优势</th><th align="left">劣势</th></tr></thead><tbody><tr><td align="center">Push</td><td align="left">1. doAction的参数由Observer定义，可以一次获取到所有需要的数据</td><td align="left">1. 不利于扩展doAction方法，比如需要更多数据时</td></tr><tr><td align="center"></td><td align="left"></td><td align="left">2. 不同的Observer可能需要的数据不同</td></tr><tr><td align="center">Pull</td><td align="left">1. Observer可以方便地获取想要的数据，不用修改doAction方法，</td><td align="left">1. 需要通过多次调用get方法来获取所有参数</td></tr><tr><td align="center"></td><td align="left">从而Subject也不需要修改调用doAction的语句</td><td align="left"></td></tr><tr><td align="center"></td><td align="left">2. 满足不同Observer需要不同数据的需求</td><td align="left"></td></tr></tbody></table><h2 id="How-如何使用观察者模式？"><a href="#How-如何使用观察者模式？" class="headerlink" title="How 如何使用观察者模式？"></a><code>How</code> 如何使用观察者模式？</h2><h3 id="案例1-Listener"><a href="#案例1-Listener" class="headerlink" title="案例1: Listener"></a>案例1: Listener</h3><p>Listener是一个非常常见的观察者模式的运用。尤其是对Event的监听。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ObserverExample</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        JButton button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token string">"doAction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        button<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AngelListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        button<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AngelListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">AngelListener</span> <span class="token keyword">extends</span> <span class="token class-name">ActionListener</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span>ActionEvent event<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// do angel action</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">DevilListener</span> <span class="token keyword">extends</span> <span class="token class-name">ActionListener</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span>ActionEvent event<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// do devil action       </span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="Ref-参考文献"><a href="#Ref-参考文献" class="headerlink" title="Ref 参考文献"></a><code>Ref</code> 参考文献</h2><p>[1] Freeman E, Robson E, Bates B, et al. Head First Design Patterns: A Brain-Friendly Guide[M]. “O’Reilly Media, Inc.”, 2004.</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design_pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful API设计概览</title>
      <link href="/2018/02/18/2018-02-18-restful-api-she-ji-gai-lan/"/>
      <url>/2018/02/18/2018-02-18-restful-api-she-ji-gai-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="What-什么是RESTful-API设计？"><a href="#What-什么是RESTful-API设计？" class="headerlink" title="What 什么是RESTful API设计？"></a><code>What</code> 什么是RESTful API设计？</h2><p>在REST中，所有的数据都以资源的形式存在。针对资源提供一系列操作接口被称为RESTful API。<br>所有的RESTful API都是对资源的操作。因此，在搞清楚RESTful API设计前，得先搞清楚什么是资源。</p><h3 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源"></a>什么是资源</h3><p>一个资源可以是一个简单的对象，也可以是对象的集合。<br>比如customers是一个对象的集合，集合中包含了多个customer，而这里的customer则是一个简单的对象。</p><p>一个资源中也可能包含其他资源。比如customer资源中，可能还包含accounts资源。<br>accounts中又包含多个account资源。</p><h3 id="什么是RESTful-API命名"><a href="#什么是RESTful-API命名" class="headerlink" title="什么是RESTful API命名"></a>什么是RESTful API命名</h3><p>那针对这些定义的资源，RESTful API使用URI（Uniform Resource Identifiers，统一资源定位符）来定位资源。<br>这些我们定义地URI就是RESTful API的命名。具体来说，针对上文中提到的customer和account两个资源。<br>我们可以为获取customer资源提供一下API：</p><pre><code>/customers/&#123;customerId&#125;</code></pre><p>以此通过传入一个customerId来获取该customer的信息。</p><p>对于嵌套存在于customer资源中的account资源，可以通过如下URI来获取：</p><pre><code>/customers/&#123;customerId&#125;/accounts/&#123;accountId&#125;</code></pre><p>通过提供customerId和accountId来得到对应customer资源下的account资源。</p><p>以上举例的两个URI便是RESTful API的命名，但不限于此。<br>获取同样的资源可以有很多不同的方式，事实上也可以使用如下方式来获取资源。</p><pre><code>/customers/&#123;customerId&#125;?accountId=&#123;accountId&#125;</code></pre><p>这样的URI也可以获取到指定customer资源中的指定account资源。<br>但这样的命名规则与前一种相比就显得没有那么简单规范了。<br>因为既使用了Route，也是用了Parameter来传递查询参数。<br>让人摸不透什么时候应该使用Route，什么时候应该使用Parameter。</p><h2 id="Why-为什么需要RESTful-API命名？"><a href="#Why-为什么需要RESTful-API命名？" class="headerlink" title="Why 为什么需要RESTful API命名？"></a><code>Why</code> 为什么需要RESTful API命名？</h2><p>一个完整统一的针对RESTful资源的命名，就好比在应用中使用了更好设计模式，提供给我们更好地可维护性。<br>针对以后的需求变更，可以更加从容地应对。<br>比如在有新的资源加入时，直接使用同样的命名规则来命名新的API即可实现扩展。</p><p>另外，清晰地命名，也会使得这些API能够被容易地使用和理解。<br>只要知道了如何操作customer，如何操作account，以后出现新的资源，也就自然而然地知道了如何操作新的资源。</p><h2 id="How-RESTful-API命名最佳实践"><a href="#How-RESTful-API命名最佳实践" class="headerlink" title="How RESTful API命名最佳实践"></a><code>How</code> RESTful API命名最佳实践</h2><p>该部分将介绍RESTful API命名的最佳实践，<br>将使用以下几类资源来进行案例分析：</p><ol><li>系统用户-user</li><li>用户的账户-account</li><li>网络设备-device</li></ol><h3 id="使用名词来表示资源"><a href="#使用名词来表示资源" class="headerlink" title="使用名词来表示资源"></a>使用名词来表示资源</h3><p>我们定义的URI都是对资源进行定位，相当于是资源的名字，而不是对资源进行操作的指令。</p><p>获取资源信息的URI可以设计如下：</p><pre><code>http://api.example.com/user-management/users/&#123;userId&#125;http://api.example.com/user-management/usershttp://api.example.com/device-management/devices/&#123;deviceId&#125;http://api.example.com/device-management/devices</code></pre><p>以上是一个简单的案例，为了更加详细地介绍，这里举出更多的例子。</p><p>资源可以被分为4类</p><ol><li><p>document</p><p>document资源就是一个单个的资源，我们可以提供URI来对这类资源进行定位：</p><pre><code>http://api.example.com/device-management/devices/&#123;device-id&#125;http://api.example.com/user-management/users/&#123;id&#125;http://api.example.com/user-management/users/admin</code></pre></li><li><p>collection</p><p>collectioin资源就是指一类资源的集合。可以使用如下方式定位一个集合：</p><pre><code>http://api.example.com/device-management/deviceshttp://api.example.com/user-management/usershttp://api.example.com/user-management/users/&#123;id&#125;/accounts</code></pre></li><li><p>store</p><p>store资源是根据客户端的需要被定义出来的一类资源的集合。案例如下：</p><pre><code># 获取用户购物车http://api.example.com/cart-management/users/&#123;id&#125;/carts# 获取用户播放列表http://api.example.com/song-management/users/&#123;id&#125;/playlists</code></pre></li><li><p>controller</p><p>Controller资源是一个程序上的概念，类似于对资源执行函数进行操作，并提供输入和输出。案例如下：</p><pre><code>http://api.example.com/cart-management/users/&#123;id&#125;/cart/checkouthttp://api.example.com/song-management/users/&#123;id&#125;/playlist/play</code></pre><p>这里我们在URI中使用了动词，因为这些操作是针对资源特有的操作，而基本的CRUD操作并不适合直接在URI中定义。<br>后文会进行详细阐述。</p></li></ol><h3 id="统一的命名规则"><a href="#统一的命名规则" class="headerlink" title="统一的命名规则"></a>统一的命名规则</h3><p>使用同一的资源命名和URI格式，可以最小限度地避免含糊不清，并最大限度地增加可读和可维护性。</p><ol><li><p>使用斜线来区别资源层级</p><pre><code>http://api.example.com/device-managementhttp://api.example.com/device-management/managed-deviceshttp://api.example.com/device-management/managed-devices/&#123;id&#125;http://api.example.com/device-management/managed-devices/&#123;id&#125;/scriptshttp://api.example.com/device-management/managed-devices/&#123;id&#125;/scripts/&#123;id&#125;</code></pre></li><li><p>不要在尾巴使用斜线</p><p>在尾巴使用斜线虽然不存在语义上的问题，但可能会造成理解上的误会。</p><pre><code># 一般的方式（存在尾部斜线）http://api.example.com/device-management/managed-devices/# 更好的方式（不存在尾部斜线）http://api.example.com/device-management/managed-devices</code></pre></li><li><p>使用连字符</p><p>使用连字符可以将URI的单词隔开，使其变得更加易读。<br>也可以使用驼峰法，但通过大小写来隔开单词的效果并没有使用连字符来隔开的效果好。</p><pre><code># 不易读http://api.example.com/inventory-management/managedEntities/&#123;id&#125;/installScriptLocation# 更易读http://api.example.com/inventory-management/managed-entities/&#123;id&#125;/install-script-location</code></pre></li><li><p>不使用下划线</p><p>虽然使用下划线也可行且具有同样好的可读性，但在某些应用中，下划线可能会被解析成特殊字符，或者被完全隐藏。<br>所以并不推荐使用下划线。</p><pre><code># 可能被错误解析http://api.example.com/inventory_management/managed_entities/&#123;id&#125;/install_script_location# 不会被错误解析http://api.example.com/inventory-management/managed-entities/&#123;id&#125;/install-script-location</code></pre></li><li><p>使用小写字母</p><p>根据<a href="http://www.rfc-base.org/txt/rfc-3986.txt">RFC 3986</a>的定义，URI中Path部分是大小写敏感的。<br>将URI规定为统一使用小写，可以降低出错可能性。</p><pre><code>http://api.example.org/my-folder/my-doc  //1HTTP://API.EXAMPLE.ORG/my-folder/my-doc  //2http://api.example.org/My-Folder/my-doc  //3</code></pre><p>上文中1的PATH（/my-folder/my-doc）和2的PATH(/my-folder/my-doc)使用了全部小写，是一样的。(Host大小写不敏感)<br>而3的PATH（/My-Folder/my-doc）则因为使用了大写而与前两个不同。</p></li><li><p>不使用文件后缀</p><p>将文件后缀用在URI中没有任何意义，但是却会让URI看起来非常奇怪。<br>因此建议不要在URI中使用没有意义的文件后缀。<br>如果需要限定请求的文件类型，可以使用HTTP请求中提供的Content-Type属性来制定。</p><pre><code># 使用了无意义的后缀http://api.example.com/device-management/managed-devices.xml# 未使用后缀http://api.example.com/device-management/managed-devices</code></pre></li></ol><h3 id="不使用CRUD函数来命名URI"><a href="#不使用CRUD函数来命名URI" class="headerlink" title="不使用CRUD函数来命名URI"></a>不使用CRUD函数来命名URI</h3><p>   URI仅仅被用来描述一个资源的位置，而不应该用来描述对资源的CRUD操作。<br>   所有对资源的CRUD操作应该使用HTTP提供的Method代替。</p><pre><code>   # 获取所有devices   HTTP GET http://api.example.com/device-management/devices   # 创建新的device   HTTP POST http://api.example.com/device-management/devices   # 获取指定Id的devices   HTTP GET http://api.example.com/device-management/devices/&#123;id&#125;   # 全部更新（没有传递的参数会被置为默认值）指定Id的device   HTTP PUT http://api.example.com/device-management/devices/&#123;id&#125;   # 部分更新（仅更新传递部分的参数）指定Id的device   HTTP PATCH http://api.example.com/device-management/devices/&#123;id&#125;   # 删除指定Id的device   HTTP DELETE http://api.example.com/device-management/devices/&#123;id&#125;</code></pre><h3 id="使用查询组件来过滤"><a href="#使用查询组件来过滤" class="headerlink" title="使用查询组件来过滤"></a>使用查询组件来过滤</h3><p>在创建你的应用时，可能会遇到下面这些情况：</p><ol><li>需要对查询到的资源进行排序，并过滤指定条数的资源</li><li>需要插入更多的查询条件</li></ol><p>这时，我们并不需要编写新的API，可以通过添加输入的参数来作为查询参数，实现以上功能。</p><pre><code># 定位所有deviceshttp://api.example.com/device-management/devices# 定位region为USA的所有deviceshttp://api.example.com/device-management/devices?region=USA# 定位region为USA且brand为XYZ的所有deviceshttp://api.example.com/device-management/managed-devices?region=USA&amp;brand=XYZ# 定位region为USA且brand为XYZ的所有devices，并按照installation-date进行排序，最终取出前10条http://api.example.com/device-management/managed-devices?region=USA&amp;brand=XYZ&amp;sort=installation-date&amp;limit=10</code></pre><h2 id="Ref-参考文献"><a href="#Ref-参考文献" class="headerlink" title="Ref 参考文献"></a><code>Ref</code> 参考文献</h2><p>[1] REST Resource Naming Guide[EB/OL] restfulapi. <a href="https://restfulapi.net/resource-naming">https://restfulapi.net/resource-naming</a>. 2018-02-18.</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF基础与实践</title>
      <link href="/2017/12/16/2017-12-16-csrf-ji-chu-yu-shi-jian/"/>
      <url>/2017/12/16/2017-12-16-csrf-ji-chu-yu-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="What-什么是CSRF？"><a href="#What-什么是CSRF？" class="headerlink" title="What 什么是CSRF？"></a><code>What</code> 什么是CSRF？</h2><p>CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式。<br>这种攻击方式可以通过伪造请求，从而以用户身份来对用户信息进行操作。<br>诸如发送邮件，发送消息，修改用户个人信息，甚至使用用户身份购买商品，进行虚拟货币的转账等等。</p><p>CSRF的原理是什么？下面通过一个实例来解释。</p><h2 id="Example-CSRF攻击实例"><a href="#Example-CSRF攻击实例" class="headerlink" title="Example CSRF攻击实例"></a><code>Example</code> CSRF攻击实例</h2><p>假设小明在浏览器中登录了Abank的网站，并且可以通过发送请求”<a href="http://abank.example/withdraw?amount=1000&amp;toAccount=1002&quot;，将1000块钱转到ID为1002的用户账户上。">http://abank.example/withdraw?amount=1000&amp;toAccount=1002&quot;，将1000块钱转到ID为1002的用户账户上。</a><br>请求会将浏览器中存储的cookie信息发送到服务器，服务器根据这些信息来获取到session中的用户信息，以此来确定此时操作的用户就是小明本人。<br>问题就在于此，小明在同一个浏览器中会浏览多个不同的网站，在打开Abank的网站并登陆成功后，还打开了Aforum.example论坛在浏览，并且被诱导点击了一个链接，这个链接会发送上述的请求。<br>这个请求虽然是在Aforum.example的页面上被触发，但浏览器会根据你发送请求的域来决定要携带的cookie，所以请求被发出并携带了用于证明小明身份的cookie中的信息。<br>最终该请求会被成功响应，从而造成小明的经济损失。服务器端不会有任何痕迹，唯一的痕迹，就是一个来自小明本人的请求，申请转账1000元到ID为1002的账户上。<br>这个攻击过程就是CSRF攻击。</p><h2 id="How-如何预防CSRF攻击"><a href="#How-如何预防CSRF攻击" class="headerlink" title="How 如何预防CSRF攻击"></a><code>How</code> 如何预防CSRF攻击</h2><p>CSRF的危害性可见一斑。那如何预防呢？目前主要有以下几种手段。</p><h3 id="1-验证HTTP-Referer字段"><a href="#1-验证HTTP-Referer字段" class="headerlink" title="1. 验证HTTP Referer字段"></a>1. 验证HTTP Referer字段</h3><p>这是最简单的预防方法。在服务器端判断HTTP报文中携带的Referer字段的值，如果不是符合要求的Referer就不予通过。<br>比如上文的例子中，小明在Aforum.example中进行操作从而发送了请求到Abank.example。<br>这时的服务器端会收到一个HTTP请求，且带有Referer属性为Aforum.example。这显然是不被允许的，所以请求不会成功。</p><p>这种方法的好处显而易见，就是简单。仅仅需要在处理请求前，加上一句判断语句即可。<br>改动也没有任何风险，因为并不会修改已有代码逻辑。</p><p>然而这种方法也存在一些缺陷。因为Referer由浏览器提供，Hacker完全可以自己构造Referer。<br>即便浏览器不允许修改Referer，但是也还是无可避免浏览器本身出现安全漏洞，从而导致Referer被更改。<br>而一旦Referer可以被修改，那这种防御方式就毫无用处。</p><h3 id="2-请求地址中添加Token验证"><a href="#2-请求地址中添加Token验证" class="headerlink" title="2. 请求地址中添加Token验证"></a>2. 请求地址中添加Token验证</h3><p>这是一种被常用的解决办法。在服务器端的session中存储一个Token，另外在每次请求的时候也附加发送该Token。<br>收到请求后，通过比对请求中的Token和服务器自身保存的Token，以此来判断请求是否安全。</p><p>这种方式比使用Referer字段更加安全，因为使用Referer的方式会将保证安全的救命稻草放到一个第三方的浏览器上，而第三方的浏览器安全性如何并不受控。<br>使用Token验证的方式，仅仅会暴露Token给用户，只要Token是安全的，这种方式便能够很好的预防CSRF攻击。</p><p>这种方式的明显缺陷就是Token泄漏。黑客如果通过某种方式得到Token，那黑客就可以发送CSRF攻击。<br>另外，这种方式还有一个缺陷，就是如何保证在需要的地方插入Token，以便用户发送请求时能够附加该Token。<br>因此这种方式会增加开发量，而且需要区别哪些地方需要加入Token，因为并不是所有的请求都需要加入Token来预防CSRF攻击。</p><h3 id="3-HTTP头中自定义属性并验证"><a href="#3-HTTP头中自定义属性并验证" class="headerlink" title="3. HTTP头中自定义属性并验证"></a>3. HTTP头中自定义属性并验证</h3><p>与上一种方法一样，这种方法也会使用Token。但不同的是，这种方法将Token置于HTTP请求的Header中，而不是直接以参数发送。<br>更进一步，取消将Token存储到服务器端的session中，取而代之的是将Token存储在Cookie中，由此完全摆脱session束缚，更加适用于微服务架构。<br>服务器收到请求后，通过比对Cookie中和Header中的Token来确定请求是否安全。</p><p>这种方法的好处在于可以摆脱session，减少了服务器端的压力，同时也使得服务器端与客户端解耦，进而更加适用于微服务架构。</p><p>这种方法的关键点在于Cookie，因为Cookie的同源读取特性，在其他网站并不能读取本站的Cookie。<br>因此这种方法的弱点也就很明显，如果Cookie泄漏，黑客便可以获取到Cookie中的Token，从而使用Token进行CSRF攻击。<br>但其实可以通过每次计算新的CSRF Token，并分别放入Cookie和请求的Header中来防止Cookie泄漏的问题。<br>因为每次请求的Token均不一样，所以即便Token被黑客拿到，这个Token也早已过期。<br>但如果黑客能够拿到修改Cookie的权限，那这种预防方式就很难保证请求的安全性了。</p><p>另外这种方式与其他使用Token的方法一样，都需要确定哪些请求需要加入Token，增加了开发量。</p><h2 id="Token-生成Token"><a href="#Token-生成Token" class="headerlink" title="Token 生成Token"></a><code>Token</code> 生成Token</h2><p>上文的第2、3种方案均用到Token。这里的Token可以被视为一个标志，应该是一个无法被计算出来的值。<br>因为如果能被计算出来，那黑客就可以轻松地获取到Token并使用Token来进行CSRF攻击了。</p><p>Token的生成原理可以简单地认为是一个随机数接上一个时间戳，并使用各种加密或者编码方式进行加密或编码。</p><p>我们并不需要重复造轮子，目前已有很多的开源库或框架可以提供生成Token的API。</p><ol><li><p>前端库中的<a href="https://www.npmjs.com/package/csrf">csrf</a></p><p>引入该库后，很简单的两三行代码便能够生成token。</p><pre><code>var Tokens = require(&#39;csrf&#39;);var secret = tokens.secretSync();var token = tokens.create(secret);</code></pre></li><li><p>后端</p><p>Spring Security本身就提供了CSRF的保护。<br>使用Spring Security的CSRF防护功能，需要进行以下配置：</p><p>3.1. 使用HTTP动词</p><p>   使用HTTP提供的各种动词，包括PATCH, POST, PUT, 和DELETE，来替代GET。<br>   因为GET请求会将参数编码到请求的URI中，从而导致信息泄露。<br>   这不是Spring做的限制，而是HTTP本身出于安全考虑的要求。</p><p>3.2. 在应用中配置CSRF保护</p><p>   对于XML配置的方式，Spring 4.0是默认打开CSRF保护功能，如果要关闭，可以使用如下配置：</p><pre class=" language-xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>http</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!-- ... --></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>csrf</span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>http</span><span class="token punctuation">></span></span></code></pre><p>   对于Java代码配置的方式，是默认打开CSRF保护功能，如果要关闭，可以使用如下配置：</p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@EnableWebSecurity</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfig</span> <span class="token keyword">extends</span>   <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       <span class="token annotation punctuation">@Override</span>       <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           http               <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>3.3. 在页面上添加CSRF Token</p><p>   在应用的页面中使用CSRF十分简单，只需要在Form中加入CSRF token的field即可。</p><p>   3.3.1. Form表单提交</p><pre class=" language-xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;logoutUrl&amp;#125;<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Log out<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;_csrf.parameterName&amp;#125;<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;_csrf.token&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>                                                 </code></pre><p>   3.3.2. AJAX请求</p><p>   可以在需要进行AJAX请求的JSP页面中添加如下代码：</p><pre class=" language-xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_csrf<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;_csrf.token&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>         <span class="token comment" spellcheck="true">&lt;!-- default header name is X-CSRF-TOKEN --></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_csrf_header<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;_csrf.headerName&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>         <span class="token comment" spellcheck="true">&lt;!-- ... --></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!-- ... --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>   然后，在jQuery中可以通过以下配置来实现对所有AJAX请求进行配置：</p><pre class=" language-renderscript"><code class="language-renderscript">   $(function () &#123;      var token = $("meta[name='_csrf']").attr("content");      var header = $("meta[name='_csrf_header']").attr("content");      $(document).ajaxSend(function(e, xhr, options) &#123;         xhr.setRequestHeader(header, token);      &#125;);   &#125;);                </code></pre><p>   Spring官方推荐使用<a href="http://cujojs.com/">cujoJS</a>中的<a href="https://github.com/cujojs/rest">rest.js</a>来进行配置</p><pre class=" language-renderscript"><code class="language-renderscript">   var client = rest.chain(csrf, &#123;      token: $("meta[name='_csrf']").attr("content"),      name: $("meta[name='_csrf_header']").attr("content")   &#125;);</code></pre><p>   相较于jQuery的方式，这种方式更加灵活，仅针对使用额client的请求才会添加CSRF，而使用jQuery的方法会对所有AJAX请求添加CSRF Token。</p></li></ol><h2 id="Ref-参考文献"><a href="#Ref-参考文献" class="headerlink" title="Ref 参考文献"></a><code>Ref</code> 参考文献</h2><p>[1] Using Spring Security CSRF Protection[EB/OL] Spring. <a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html">https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html</a>. 2018-02-18.</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csrf </tag>
            
            <tag> web </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当你在浏览器输入URL并回车发生了什么</title>
      <link href="/2017/12/10/2017-12-10-dang-ni-zai-liu-lan-qi-shu-ru-url-bing-hui-che-fa-sheng-liao-shi-me/"/>
      <url>/2017/12/10/2017-12-10-dang-ni-zai-liu-lan-qi-shu-ru-url-bing-hui-che-fa-sheng-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>‘当你在浏览器中输入Google.com并按下回车后，发生了什么？’。<br>这是一个使用浏览器进行资源访问的常见场景。<br>作为一个如今高频发生的事情，它看起来是非常简单的。<br>浏览器发送请求，通过网络传输，服务器收到请求并返回处理后的信息。<br>似乎一句话便能说清楚的问题，却是一个被人讨论无数次，并认为是一个难以回答清楚的问题。<br>Why？这个看似简单的明了的问题，其实涉及了底层硬件，操作系统，计算机网络…等等多个领域。<br>想要细致地回答这个问题，并没有想象中那样简单。<br>操作系统如何知道你输入的是”G”而不是”B”？<br>信息是如何被操作系统发出？又如何在茫茫的网络空间中精准地找到目标？…<br>每个问题几乎都是一个领域的缩影。<br>那当我们躺在屋里享受着Google带来的便捷之时，背后究竟发生了什么呢？</p><h2 id="输入URL"><a href="#输入URL" class="headerlink" title="输入URL"></a>输入URL</h2><h3 id="键盘输入URL"><a href="#键盘输入URL" class="headerlink" title="键盘输入URL"></a>键盘输入URL</h3><p>首先第一步，输入URL。从按下键盘到浏览器接收到输入，这个过程涉及了物理键盘、系统中断、汇编方面的内容。<br>当你按下键盘，一个用于该键的电流回路被直接或者通过电容器间接的闭合，因此电流进入键盘的逻辑电路系统。<br>这个逻辑电路系统检测到该按键的状态变化，将电流信号转换为键盘码值（通过汇编程序）。<br>键盘控制器得到码值后，将其编码，用于之后的传输。如今这个传输介质通常为串行总线（USB）或蓝牙，以前主要通过PS/2或者ADB。</p><p>键盘将输入的编码（一个整形数）通过IRQ（Interrupt Request，中断请求）发送，由OS的内核提供的中断处理器进行处理。<br>最终操作系统可以得到输入的具体内容。</p><h2 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h2><h3 id="按下回车"><a href="#按下回车" class="headerlink" title="按下回车"></a>按下回车</h3><p>当你按下回车，按照上文阐述的过程，回车信号被操作系统捕获，解析URL的过程被触发。</p><h3 id="判断是URL还是搜索关键字"><a href="#判断是URL还是搜索关键字" class="headerlink" title="判断是URL还是搜索关键字"></a>判断是URL还是搜索关键字</h3><p>浏览器首先会检测输入的URL的合法性。通过检测协议和主机名来进行合法性检测。<br>如果不是一个合法的URL，浏览器则会将输入视为一个搜索关键字。</p><h3 id="检查HSTS列表"><a href="#检查HSTS列表" class="headerlink" title="检查HSTS列表"></a>检查HSTS列表</h3><p>HSTS（HTTP Strict Transfer Security，HTTP严格传输安全）是浏览器存储的一个列表，列表中包含了只能使用HTTPS来进行访问的网站。<br>之所以使用HSTS，主要是为了避免用户受到降级攻击。因为用户可能会发送HTTP请求，被服务器拒绝后，才会重新发送HTTPS请求。<br>而第一次的HTTP请求并不安全。浏览器内置的HSTS就可以一定程度的解决这个问题。</p><h3 id="转换非ASCII的Unicode字符"><a href="#转换非ASCII的Unicode字符" class="headerlink" title="转换非ASCII的Unicode字符"></a>转换非ASCII的Unicode字符</h3><p>浏览器会检查传输的数据是否包含有<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，<code>-</code>，<code>.</code>以外的字符。<br>如果存在不合规的字符，则对其进行编码，可以通过不同的编码规则进行编码（UTF8，GBK等）。</p><h2 id="访问URL"><a href="#访问URL" class="headerlink" title="访问URL"></a>访问URL</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS查询的步骤如下：</p><ol><li><p>检查浏览器缓存</p><p> 浏览器会维护一个常用的DNS解析列表，表中记录了常用的域名及其对应的IP</p></li><li><p>检查操作系统缓存</p><p> 调用gethostbynme库函数（操作系统不同函数也不同）进行查询，查询域名是否在本地Hosts中</p></li><li><p>检查路由器缓存</p><p> 路由器也维护了一个域名解析列表，在之前均检查失败的情况下会检查路由器缓存。</p></li><li><p>检查ISP缓存</p><p> 如果在本地解析均失败，则发送请求到ISP的DNS服务器上进行解析。<br> ISP的DNS解析过程是一个递归的解析过程，从根域名开始解析。<br> 比如需要解析<code>www.wikipedia.org</code>, 会经历以下几步：</p><ol><li><p>通过保存在本地的IP，访问根域名系统（包含org的域名系统，即顶级域名系统），获取到下一步需要访问的域名系统的IP；</p></li><li><p>通过上一步获取到的IP，访问org的域名系统（包含wikipedia的域名系统），获取到再下一步的域名系统的IP；</p></li><li><p>通过上一步获取到的IP，访问wikipedia.org的域名系统，获取到最终的访问目标IP。</p><p>步骤示意图如下所示：</p><p><img src="https://en.wikipedia.org/wiki/File:Example_of_an_iterative_DNS_resolver.svg" alt="Address Resolution"></p></li></ol></li></ol><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>上一步讲了DNS解析的大致过程，但有一个问题。我们如何能够通过一个目标IP就能访问到路由器以及ISP的域名服务器呢？<br>其实是使用了ARP请求。</p><p>ARP（Address Resolution Protocol，地址解析协议），意在通过IP地址解析得到链路层地址，比如MAC地址。<br>主要用于数据链路层的通信（OSI七层模型，在TCP/IP模型中属于网络层）。<br>当我们需要访问DNS服务器时，ARP请求的步骤大致如下：</p><ol><li>通过IP查找本地缓存的ARP列表，找到则返回MAC地址；</li><li>如果本地缓存未命中，则查看网络存储设备（路由器）中的路由表，发现目标IP在本地路由表中的某个子网中，则向该子网广播ARP请求；</li><li>如果路由表未命中，则向默认网关发送ARP请求；</li><li>如果默认网关未命中，则再向默认网关所在的网络进行广播ARP请求，直到命中或失败。</li></ol><h3 id="使用Socket通信"><a href="#使用Socket通信" class="headerlink" title="使用Socket通信"></a>使用Socket通信</h3><p>找到目标IP的确切位置后，调用系统库函数sockt，请求一个TCP套接字。<br>这个请求会被逐层封装，大致经过以下几步：</p><ol><li><p>传输层处理</p><p> 传输层将TCP请求封装成TCP报文。各种信息被写入TCP报文的头部。</p></li><li><p>网络层处理</p><p> 网络层主要将上一层生成的TCP报文进行处理，加入一个IP头部。封装成IP报文。主要包括目标IP以及源IP地址。</p></li><li><p>链路层处理</p><p> 链路层在IP报文外封装一个frame头部，包括了本地网卡的MAC地址以及网关的MAC地址等信息。如上文述，发送TCP报文需要MAC地址。</p></li><li><p>物理层传输</p><p> 物理层主要根据传输介质的不同，将报文转换为各种适于传输的格式。<br> 常见的传输介质有以下几种：</p><ol><li><p>以太网</p></li><li><p>WiFi</p></li><li><p>蜂窝数据网络</p><p>使用电话线路、有线电视光缆和无限电话线路来进行传输时，需要使用调制解调器将报文的数字信号转换成模拟信号，接收端再使用另一个调制解调器进行逆向转换。</p><p>如果使用光纤进行传输，则无需进行调制解调。</p></li></ol></li></ol><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>上文介绍TCP/IP通信时每个数据包传输的具体过程。这部分介绍TCP/IP进行通信的过程，即三次握手。</p><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。<br>在socket编程中，这一过程由客户端执行connect来触发。</p><p>三次握手示意图：</p><p><img src="https://i.loli.net/2018/02/10/5a7e5f79d52be.png" alt="三次握手示意图"></p><p>三次握手解释如下：</p><ol><li><p>第一次握手</p><p> Client将标志位SYN置为1，随机产生一个值seq=J（seq是TCP首部的序号），并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p></li><li><p>第二次握手</p><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1（ack是TCP首部的确认号），<br>随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p></li><li><p>第三次握手</p><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，<br>Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，<br>随后Client与Server之间可以开始传输数据了。</p></li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>在断开TCP连接时，会进行四次挥手。<br>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。<br>在Socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p><p>四次挥手示意图：</p><p><img src="https://i.loli.net/2018/02/10/5a7ecf3e29445.png" alt="四次挥手"></p><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭。<br>这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，<br>即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。<br>首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><p>四次挥手解释如下：</p><ol><li><p>第一次挥手</p><p>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手</p><p>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p></li><li><p>第三次挥手</p><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p></li><li><p>第四次挥手</p><p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></li></ol><h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>对于长连接，TCP连接并不会在一次通信完成后就执行四次挥手来断开连接，而是一直保持连接。通过定时发送心跳检测数据包来维持连接。<br>长连接对于服务器的压力会非常大，普通的开发者难以实现。</p><h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><p>TLS（Transport Layer Security，传输层安全）旨在为网络通信过程提供安全及数据完整的传输。<br>在TCP/IP四层模型中，介于应用层和传输层之间。</p><p>TLS的握手过程大致如下：</p><ol><li>客户端发送一个Hello消息到服务器端，消息主要用来告知服务器端，客户端使用的TLS的版本，可用的加密算法和压缩算法。</li><li>服务器端返回一个Hello消息到客户端，消息用于确认通信将使用的TLS版本，加密算法和压缩算法。另外还包括服务器的公开证书以及其公钥。</li><li>客户端根据自己信任的CA列表，验证服务器端的证书是否有效。</li><li>如果证书有效，则客户端生成一个伪随机数，并根据伪随机数生成对称密钥，并使用使用服务器端提供的公钥加密它，并发送给服务器。至此TLS握手完成。</li><li>服务器使用私钥解密得到对称密钥，由此双方可以使用该对称密钥进行安全通信。</li></ol><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p><a href="https://www.w3.org/Protocols/">HTTP</a>属于TCP/IP协议栈中的应用层协议。<br>通过TLS建立安全的TCP连接后，则可以通过HTTP请求来进行数据的传输了。</p><p>HTTP请求包含多种类型，比如GET请求。</p><p>一个GET请求的样例如下：</p><pre><code>GET http://google.com/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:29.0) Gecko/20100101 Firefox/29.0Accept-Encoding: gzip, deflateConnection: Keep-AliveHost: google.comCookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...]</code></pre><p>如上所示，HTTP请求报文头部会在中放入一些元信息。<br>比如定义可以接受的响应文件类型（Accept），是否保持TCP连接（Connection），以及浏览器保存的Cookie信息（Cookie）。</p><p>服务器处理完请求后，会返回一个HTTP响应。</p><p>上述GET请求的响应如下：</p><pre><code>HTTP/1.1 200 OKCache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0Expires: Thu, 19 Nov 1981 08:52:00 GMTPragma: no-cacheContent-Encoding: gzipContent-Type: text/html; charset=utf-8Connection: Keep-AliveContent-length: 1215Date: Sat, 10 Feb 2018 20:11:20 GMT</code></pre><p>如上所述，HTTP响应以返回的状态码开始，后面包括响应内容的编码方式（Content-Encoding），内容长度（Content-length）等。</p><p>其中返回的状态码包括以下几类：</p><ol><li>1xx，信息类状态码，表示请求正在被处理。</li><li>2xx，成功状态码，表示请求处理成功。</li><li>3xx，重定向状态码，表示需要进行附加操作以完成请求。</li><li>4xx，客户端错误状态码，表示服务器无法处理请求。</li><li>5xx，服务器端错误状态码，表示服务器处理请求错误。</li></ol><h3 id="HTTP服务器请求处理"><a href="#HTTP服务器请求处理" class="headerlink" title="HTTP服务器请求处理"></a>HTTP服务器请求处理</h3><p>HTTPD（HTTP Daemon，HTTP后台驻留程序）在服务器端处理HTTP请求。<br>常见的HTTPD有Linux上的Apache和Nginx，Windows上的IIS。</p><p>HTTPD处理HTTP请求的步骤如下：</p><ol><li>接收请求</li><li>获取到请求方法、域名、请求路径</li><li>验证服务器上已配置google.com的虚拟主机</li><li>验证google.com接受GET方法</li><li>验证该用户可以使用GET方法（根据IP地址，身份信息）</li><li>如果服务器安装了URL重写模块，服务器会尝试匹配重写规则进行重写请求</li><li>服务器根据请求信息获取到响应内容</li><li>使用指定的程序处理响应内容，比如PHP来解析响应内容</li></ol><p>具体来说，在Java平台，我们常常会使用Tomcat来处理HTTP请求。<br>使用Tomcat来处理HTTP请求的步骤如下：</p><ol><li>HTTP请求被操作系统转发给Tomcat监听的端口</li><li>解析请求并封装成Request对象</li><li>Engine容器处理Request</li><li>Host容器处理Request</li><li>Context容器处理Request</li><li>Wrapper容器处理Request</li><li>逐级返回，最终返回Response对象，并转换成HTTP响应</li></ol><h2 id="浏览器解析"><a href="#浏览器解析" class="headerlink" title="浏览器解析"></a>浏览器解析</h2><p>当浏览器获取到服务器返回的HTTP响应文件后，浏览器会执行下面的操作：</p><ol><li>解析HTML，CSS，JS</li><li>渲染（包括构建DOM，渲染，布局，绘制）</li></ol><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器的主要功能是帮助用户请求资源，并进行展示。<br>这些资源通常是HTML，也可以是PDF，图片等其他文件。<br>资源的位置通过用户提供的URI(Uniform Resource Identifier)来确定。<br>目前通过HTTP请求访问的资源都提供了准确的访问地址，因此URI也是URL。</p><p>浏览器解释和展示HTML文件的方法，在HTML和CSS的标准中有详细介绍。<br>这些标准由Web标准组织W3C(World Wide Web Consortium)维护。</p><p>一个浏览器的组件主要包括以下几个部分：</p><ol><li><p>用户界面 </p><p>用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分。</p></li><li><p>浏览器引擎 </p><p>浏览器引擎负责让UI和渲染引擎协调工作。</p></li><li><p>渲染引擎 </p><p>渲染引擎负责展示请求内容。如果请求的内容是HTML，渲染引擎会解析HTML和CSS，然后将内容展示在屏幕上。</p></li><li><p>网络组件 </p><p>网络组件负责网络调用，例如HTTP请求等，使用一个平台无关接口，下层是针对不同平台的具体实现。</p></li><li><p>UI后端 </p><p>UI后端用于绘制基本UI组件，例如下拉列表框和窗口。<br>UI后端暴露一个统一的平台无关的接口，下层使用操作系统的UI方法实现</p></li><li><p>Javascript解释器 </p><p>Javascript解释器用于解析和执行Javascript代码。</p></li><li><p>数据存储 </p><p>数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如Cookie等。<br>浏览器也需要支持诸如localStorage，IndexedDB，WebSQL和FileSystem之类的存储机制。</p></li></ol><h3 id="HTML解析"><a href="#HTML解析" class="headerlink" title="HTML解析"></a>HTML解析</h3><p>浏览器拿到具体的HTML文档之后，调用浏览器引擎中的HTML Parser来将HTML文档解析成为DOM树，将以便外部接口（JS）调用。</p><p>整个解析分为两步：</p><ol><li><p>文档内容解析</p><p>从HTTP的Response中分析出结构化的信息，让HTML解析器可以很方便地提取数据进行其他操作。<br>这个过程包括两个内容：</p><ol><li>词法分析，将字符串切分成符合特定语法规范的符号</li><li>语法分析，根据符合语法规范的符号构建对应该文档的语法树</li></ol></li><li><p>HTML解析</p><p>根据HTML语法，将HTML标记到语法树上构建成DOM(Document Object Model)。</p></li></ol><h3 id="CSS解析"><a href="#CSS解析" class="headerlink" title="CSS解析"></a>CSS解析</h3><p>根据CSS词法和句法分析CSS文件和<code>&lt;style&gt;</code>标签包含的内容以及style属性的值。<br>每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象。</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>HTML解析后会得到一个DOM节点树。页面渲染时，首先会通过遍历这个DOM节点树创建一个“Frame树”或“渲染树”，并计算每个节点的各个CSS样式值。</p><h3 id="GPU渲染"><a href="#GPU渲染" class="headerlink" title="GPU渲染"></a>GPU渲染</h3><p>在渲染过程中，图形处理层可能使用通用用途的CPU，也可能使用图形处理器GPU。<br>当使用GPU用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用GPU强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</p><h3 id="后期渲染与用户引发的处理"><a href="#后期渲染与用户引发的处理" class="headerlink" title="后期渲染与用户引发的处理"></a>后期渲染与用户引发的处理</h3><p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。<br>类似Flash和Java的插件也会运行。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>What happens when you type a URL in browser[EB/OL] Pankaj Pal. <a href="http://edusagar.com/articles/view/70/What-happens-when-you-type-a-URL-in-browser">http://edusagar.com/articles/view/70/What-happens-when-you-type-a-URL-in-browser</a>. 2018-02-10.</li><li>Address resolution mechanism[EB/OL] wikipedia. <a href="https://en.wikipedia.org/wiki/Domain_Name_System#Address_resolution_mechanism">https://en.wikipedia.org/wiki/Domain_Name_System#Address_resolution_mechanism</a>. 2018-02-10.</li><li>在浏览器中输入Google.com并且按下回车之后发生了什么？[EB/OL] cnblogs. <a href="https://kb.cnblogs.com/page/516964">https://kb.cnblogs.com/page/516964</a>. 2018-02-10.</li></ol>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
            <tag> browser </tag>
            
            <tag> dns </tag>
            
            <tag> arp </tag>
            
            <tag> tcp </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API的不同架构风格概述</title>
      <link href="/2017/11/27/2017-11-27-api-de-bu-tong-jia-gou-feng-ge-gai-shu/"/>
      <url>/2017/11/27/2017-11-27-api-de-bu-tong-jia-gou-feng-ge-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="定义-API的基本概念？"><a href="#定义-API的基本概念？" class="headerlink" title="定义 API的基本概念？"></a><code>定义</code> API的基本概念？</h2><p>目前的网络应用程序，基本都分为应用端和服务端。应用端负责直接将应用的内容呈现给用户，服务端负责处理数据及其业务逻辑。<br>通常应用端的展现在用户可以直接接触到的诸如手机、平板、电脑等多种设备上进行。而服务端通常在一个逻辑单位的服务器上运行。<br>为了方便二者进行通讯，需要定义一个统一的机制，方便用户通过不同的应用端来访问服务端。<br>我们通过提供API来实现这种这一过程。</p><p>简而言之，API就是服务端提供给应用端使用的获取服务端数据的方法。</p><h2 id="架构风格-API的几种架构风格"><a href="#架构风格-API的几种架构风格" class="headerlink" title="架构风格 API的几种架构风格"></a><code>架构风格</code> API的几种架构风格</h2><p>目前的API架构主要有以下几种：</p><ol><li>RPC(Remote Procedure Call)</li><li>REST(Representational State Transfer)</li><li>Event-driven</li><li>GraphQL</li></ol><h3 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1. RPC"></a>1. <code>RPC</code></h3><h4 id="RPC概念"><a href="#RPC概念" class="headerlink" title="RPC概念"></a>RPC概念</h4><p>RPC是一种进程间的通信技术。被设计用来构建分布式计算。<br>RPC可以满足远程调用的同时，又使得执行的程序语义简洁。</p><p>RPC分为同步和异步两种情况。<br>其中同步方式，指客户端向服务器端发送请求，客户端阻塞等待服务器端执行一段程序并返回响应。<br>客户端收到响应后，重新进入可执行状态。<br>而异步方式，则客户端无需阻塞等待。客户端可以通过回调函数来得到RPC的执行结果。</p><h4 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h4><p>RPC的方法调用过程如下图所示：<br><img src="https://i.loli.net/2017/11/29/5a1ec5279c1f3.png" alt="RPC方法调用过程"></p><p>客户端引入一个远程的方法，并在本地程序中如同本地方法一样进行调用。但实际的调用过程是图中所示的步骤来进行的。<br>首先调用会被proxy进行封装，然后proxy通过invoker来执行调用。<br>Invoker则通过调用Connector来与服务器端进行通信。<br>Connector会将调用信息进行编码，然后通过自己维护的Channel来讲调用消息发送给服务器端。<br>服务器端收到调用消息后，使用同样的协议来解码，并将调用信息交给Processor来处理。<br>最后由Invoker来完成方法的调用并反回结果。</p><h4 id="RPC实现"><a href="#RPC实现" class="headerlink" title="RPC实现"></a>RPC实现</h4><p>目前RPC的相关实现方法有以下几种：</p><ol><li>JavaRMI</li><li>XML-RPC，XML+HTTP来进行机器之间的调用</li><li>JSON-RPC</li><li>SOAP，XML-RPC的升级版</li><li>Facebook Thrift</li><li>CORBA</li><li>AMF，AdobeFlex</li><li>Libevent，是一个用于构建RPC Server和Client的框架。</li><li>WCF，来自微软</li><li>.Net Remoting，逐步被WCF取代</li></ol><h3 id="2-REST"><a href="#2-REST" class="headerlink" title="2. REST"></a>2. <code>REST</code></h3><h4 id="REST概念"><a href="#REST概念" class="headerlink" title="REST概念"></a>REST概念</h4><p>REST出自Roy Fielding的一篇2000年刊出的博士论文。<br>该论文中，Fielding提出网络交互中的风格比网络交互中的协议对整个网络通信过程的影响力更大。<br>进而，本文也就提出了一种网络交互的风格，称之为REST（Representational State Transfer，表现层状态转化）。<br>所有符合REST风格的应用，称之为RESTful的应用。</p><h4 id="REST的目的"><a href="#REST的目的" class="headerlink" title="REST的目的"></a>REST的目的</h4><p>REST被设计出来的目的在于，构建一个良好的网络应用架构，<br>使得该应用能够适用于不同的客户端以及不断更新的需求和技术。</p><p>具体来说有三个方面：</p><ol><li>适应服务端服的变化，即服务端实现技术或平台变化后，该架构依然适用。</li><li>适应客户端的变化，即客户端实现技术或平台变化后，该架构依然适用。</li><li>适应应用本身的变化，即应用的功能变化后，该架构依然适用。</li></ol><h4 id="REST之Resource"><a href="#REST之Resource" class="headerlink" title="REST之Resource"></a>REST之Resource</h4><p>REST的完整称呼应该叫Resource REST。Resouce（资源）是REST风格架构中最重要的部分。<br>通常使用URL[^1]来表示资源，通过访问URL来获取资源即是网络交互的目的。<br>REST设计风格也就是URL的一种设计风格。</p><h4 id="REST之Representational"><a href="#REST之Representational" class="headerlink" title="REST之Representational"></a>REST之Representational</h4><p>REST中的Representational（表现层），即展现资源的一层。<br>这里的资源可以是各种类型的文件，html、jpg、txt等等。<br>这些资源也可以在不同的设备和不同的OS上进行展现。<br>REST风格架构的应用，应当能够支持在不同设备和OS上进行资源的展示。</p><h4 id="REST之State-Transfer"><a href="#REST之State-Transfer" class="headerlink" title="REST之State Transfer"></a>REST之State Transfer</h4><p>REST中的State Transfer（状态转化），即用户和资源服务器进行交互时，对资源进行操作而导致的资源状态变化的这个过程。<br>REST状态转化中的通信过程是基于HTTP协议来进行的。REST风格架构中使用HTTP中包含的各种操作来对资源的状态进行修改。<br>其中GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。</p><h4 id="API的最佳实践"><a href="#API的最佳实践" class="headerlink" title="API的最佳实践"></a>API的最佳实践</h4><ol><li><p>URL使用名词复数，避免动词</p><p>REST中认为资源是一种实体，所有的操作应该通过HTTP来实现。所以URL只包含名词，仅仅用来表达一个资源实体。</p><p>一个错误的演示如下</p><pre><code>GET /getProductsGET /getProducts/1POST /addProducts/1</code></pre><p>正确的演示如下</p><pre><code>GET /productsGET /products/1POST /products/1</code></pre></li><li><p>HTTP状态码</p><p>使用正确的[]HTTP状态码](<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)来表示不同的请求结果。">https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)来表示不同的请求结果。</a></p></li><li><p>加入版本管理</p><p>可以再URL中加入版本号，如下</p><pre><code>api/v1/savings</code></pre><p>或者也可以在HTTP的header中加入版本号，如下</p><pre><code>Accept: bank.example.com+json; version=1.0</code></pre></li><li><p>使用URL Root</p><pre><code>www.example.com/api/v1/**</code></pre></li></ol><h3 id="3-Event-driven"><a href="#3-Event-driven" class="headerlink" title="3. Event-driven"></a>3. <code>Event-driven</code></h3><p>API的调用通常是由客户端发起，服务器端进行响应。Event-driven（事件驱动）型API则正好相反。<br>通常由应用程序提供相应接口，并注册到服务器上。当相关事件被触发，服务器会调用客户端注册的接口。</p><h3 id="4-GraphQL"><a href="#4-GraphQL" class="headerlink" title="4. GraphQL"></a>4. <code>GraphQL</code></h3><p>GraphQL是FaceBook的一个新的查询和获取应用所需数据的语言。<br>GraphQL并不是一个简单的查询语言，而是一个数据抽象层，包括了数据格式、数据关联、查询方式定义与实现等等功能。</p><p>GraphQL、客户端应用程序、数据之间的关系如下图所示。<br><img src="https://i.loli.net/2017/12/03/5a23e6aa67883.png" alt="GraphQL"></p><p>与REST相同，基于GraphQL的架构也分离了前后端，也适用于无状态请求。<br>但GraphQL定义了更严格、可扩展、可维护的数据查询方式。<br>使得GraphQL支持复杂资源间关联的请求。</p><p>比如一个GraphQL的请求</p><pre><code>    &#123;        post &#123;            id,            title,            date,            content,            author &#123;                id,                name            &#125;,            comments &#123;                content,                author &#123;                    id,                    name                &#125;            &#125;        &#125;    &#125;</code></pre><p>这样一个请求返回了一个post的相关内容以及评论的相关内容。<br>这是一个资源关联复杂的请求，如果要使用REST来获取这些数据，要么需要单独写一个API来处理请求，要么就需要多次请求。<br>而GraphQL能够较好的处理这种情况。</p><p>[^1]:<br>    URL（Uniform Resource Locator，统一资源定位符），表示一个资源的位置，可以通过该位置找到该资源，同时该位置也是一个唯一标识符。</p><pre><code>URI（Uniform Resource Identifier，统一资源标识符），表示一个资源的唯一标识符，通过URI可以唯一标识该资源。属于URL的父级。</code></pre>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
            <tag> rpc </tag>
            
            <tag> restful </tag>
            
            <tag> event_driven </tag>
            
            <tag> graphql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定制化Spring-Security</title>
      <link href="/2017/11/06/2017-11-06-ding-zhi-hua-spring-security/"/>
      <url>/2017/11/06/2017-11-06-ding-zhi-hua-spring-security/</url>
      
        <content type="html"><![CDATA[<h2 id="定义-什么是Spring-Security？"><a href="#定义-什么是Spring-Security？" class="headerlink" title="定义 什么是Spring Security？"></a><code>定义</code> 什么是Spring Security？</h2><p>借用Spring Security官方的介绍</p><blockquote><p>Spring Security is a powerful and highly customizable authentication and access-control framework.<br>It is the de-facto standard for securing Spring-based applications.</p></blockquote><p>Spring Security（后文称SS）主要关注与两个方面的功能，一个是<code>认证</code>，另一个是<code>授权</code>。<br>SS的强大之处在于，它可以非常简单的适用于各种场景下的<code>认证</code>和<code>授权</code></p><p>官方也介绍了SS的几个特点</p><blockquote><p>1, Comprehensive and extensible support for both Authentication and Authorization</p><p>2.Protection against attacks like session fixation, clickjacking, cross site request forgery, etc</p><p>3.Servlet API integration</p><p>4.Optional integration with Spring Web MVC</p><p>5.Much more…</p></blockquote><h2 id="用法-Spring-Security的常见用法"><a href="#用法-Spring-Security的常见用法" class="headerlink" title="用法 Spring Security的常见用法"></a><code>用法</code> Spring Security的常见用法</h2><p>SS的用法主要有四种：</p><ol><li>全部使用配置文件</li><li>使用SS的默认数据库</li><li>自定义filter</li><li>修改源码</li></ol><p>这四种方法的实现是由简到难的,适用范围也是由窄入宽。</p><p>第一种用法，就是官方的Demo中展示的方法。没有数据库，将所有数据以配置文件的方式存放。</p><p>第二种用法，使用固定的数据库，无法使用自定义的user和role的数据，也无法自定义授权方式。</p><p>第三种用法，通过自定义filter，来使用自定义的user和role数据，并且可以重写授权的逻辑。这是最为常用的方法。</p><p>第四种用法，暴力修改源码，这样的方法违背OO设计原则，实现起来也非常复杂，几乎没有被用到的方法。</p><h2 id="自定义-如何自定义Spring-Security以匹配自己的用户、角色、资源"><a href="#自定义-如何自定义Spring-Security以匹配自己的用户、角色、资源" class="headerlink" title="自定义 如何自定义Spring Security以匹配自己的用户、角色、资源"></a><code>自定义</code> 如何自定义Spring Security以匹配自己的用户、角色、资源</h2><p>上述第三种用法被广泛地运用在各个以SS作为权限管理模块的项目中。<br>所以其他方法就不在赘述，直接介绍最有实际应用价值的第三种用法。</p><h3 id="Spring-Security认证授权结构"><a href="#Spring-Security认证授权结构" class="headerlink" title="Spring Security认证授权结构"></a>Spring Security认证授权结构</h3><p>SS进行认证授权，可以大致分为两个部分：</p><ol><li><p>认证 - 验证用户身份</p><p> 由SS中的<code>登录验证拦截器</code>进行处理</p></li><li><p>授权 - 验证用户所拥有的角色是否具有访问资源所需要的权限。</p><p> 由SS中的<code>资源管理拦截器</code>进行处理</p></li></ol><p>拦截器是实现SS的基本，所有SS的逻辑均通过这些拦截器实现。以上两个拦截器只是SS中众多拦截器的一瞥。下面从用户使用应用的流程来介绍SS的作用原理。首先用一个图来简单描述一下交互的过程。</p><p><img src="https://i.loli.net/2017/11/19/5a105d618fbf7.png" alt="用户与SS交互示意图">{:height=”400px” width=”100px”}</p><p>可以看出SS中最核心的部分就是那些SS中实现的拦截器。通过对SS源程序(v3.2.6)进行调试，可以看到SS的拦截器一共有12个，如下图所示。</p><p><img src="https://i.loli.net/2017/11/18/5a104975e1c09.png" alt="SS Filters">{:height=”400px” width=”500px”}</p><p>其中：</p><ol><li>WebAsyncManagerIntegrationFilter - 集成SecurityContext和WebAsyncManager</li><li>SecurityContextPersistenceFilter - SecurityContext的组装，供后续的过滤器链来使用，如果用户已经登录，再次访问其他资源时，会根据sessionId在session中将已保存的SecurityContext取出</li><li>HeaderWriterFilter - 给当前的请求增加头部信息</li><li>LogoutFilter - 用于完成SS中配置的logout的功能</li><li>UsernamePasswordAuthenticationFilter - 验证用户的登录凭证，并进行认证授权</li><li>ConcurrentSessionFilter - 更新session中的用户登录状态，并且检查session是否已经失效</li><li>RequestCacheAwareFilter - 设置用于用户登录成功后，重新恢复因为登录被打断的请求</li><li>SecurityContextHolderAwareRequestFilter - 包装请求对象request</li><li>AnonymousAuthenticationFilter - 如果之前的过滤器没有认证成功，在这里提供一个匿名的认证</li><li>SessionManagementFilter - 确认请求已经获得了任何一种认证，并执行一些session的保护机制，比如验证是否存在同一用户同时登陆</li><li>ExceptionTranslationFilter - 处理所有的AccessDeniedException和AuthenticationException，将这些Java异常转换为响应</li><li>FilterSecurityInterceptor - 用于处理自定义来实现权限控制逻辑的情况</li></ol><p>就是以上这些拦截器完成了SS的工作。用户的每请求一次，所有的过滤器都会按照顺序被调用一次。</p><h3 id="Spring-Security配置实例"><a href="#Spring-Security配置实例" class="headerlink" title="Spring Security配置实例"></a>Spring Security配置实例</h3><p>可以从配置文件来说明该方法的用法。</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/security<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">xmlns:</span>b</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd                          http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--登录页面不过滤 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>http</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>http</span> <span class="token attr-name">access-denied-page</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/accessDenied.jsp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form-login</span> <span class="token attr-name">login-page</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>          <span class="token comment" spellcheck="true">&lt;!--访问/admin.jsp资源的用户必须具有ROLE_ADMIN的权限 --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intercept-url</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/admin.jsp<span class="token punctuation">"</span></span> <span class="token attr-name">access</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ROLE_ADMIN<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>         <span class="token comment" spellcheck="true">&lt;!--访问/**资源的用户必须具有ROLE_USER的权限 --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intercept-url</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/**<span class="token punctuation">"</span></span> <span class="token attr-name">access</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ROLE_USER<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-management</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>concurrency-control</span> <span class="token attr-name">max-sessions</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">error-if-maximum-exceeded</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-management</span><span class="token punctuation">></span></span>          <span class="token comment" spellcheck="true">&lt;!--增加一个filter，这个filter位于FILTER_SECURITY_INTERCEPTOR之前 --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-filter</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myFilter<span class="token punctuation">"</span></span> <span class="token attr-name">before</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILTER_SECURITY_INTERCEPTOR<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>http</span><span class="token punctuation">></span></span>          <span class="token comment" spellcheck="true">&lt;!--一个自定义的filter，必须包含 authenticationManager,accessDecisionManager,securityMetadataSource三个属性，           我们的所有控制将在这三个类中实现，解释详见具体配置 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myFilter<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.myapp.spring.security.MyFilterSecurityInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>authenticationManager<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>authenticationManager<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accessDecisionManager<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myAccessDecisionManagerBean<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>securityMetadataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>securityMetadataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">b:</span>bean</span><span class="token punctuation">></span></span>          <span class="token comment" spellcheck="true">&lt;!--验证配置，认证管理器，实现用户认证的入口，主要实现UserDetailsService接口即可 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>authentication-manager</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>authenticationManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>authentication-provider</span> <span class="token attr-name">user-service-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myUserDetailService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>              <span class="token comment" spellcheck="true">&lt;!--如果用户的密码采用加密的话 &lt;password-encoder hash="md5" /> --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>authentication-provider</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>authentication-manager</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--在这个类中，你就可以从数据库中读入用户的密码，角色信息，是否锁定，账号是否过期等 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myUserDetailService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.erdangjiade.spring.security.MyUserDetailService<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>          <span class="token comment" spellcheck="true">&lt;!--访问决策器，决定某个用户具有的角色，是否有足够的权限去访问某个资源 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myAccessDecisionManagerBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.erdangjiade.spring.security.MyAccessDecisionManager<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token comment" spellcheck="true">&lt;!--资源源数据定义，将所有的资源和权限对应关系建立起来，即定义某一资源可以被哪些角色访问 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">b:</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>securityMetadataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.erdangjiade.spring.security.MyInvocationSecurityMetadataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">b:</span>beans</span><span class="token punctuation">></span></span></code></pre><p>以上是一个包含了自定义认证和自定义授权的Spring Security配置实例。</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> auth </tag>
            
            <tag> security1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible概览</title>
      <link href="/2017/11/02/2017-11-02-ansible-gai-lan/"/>
      <url>/2017/11/02/2017-11-02-ansible-gai-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="What-什么是Ansible？"><a href="#What-什么是Ansible？" class="headerlink" title="What 什么是Ansible？"></a><code>What</code> 什么是Ansible？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Ansible是一个自动化运维工具，一个执行框架/引擎。基于Python开发。</p><p>Ansible集合了众多运维工的优点，诸如puppet、cfengine、chef、func、fabric。</p><p>Ansible主要用于实现批量系统配置、批量程序部署、批量运行命令等功能。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Ansible主要有以下特点：</p><ol><li>无代理</li><li>安装简单</li><li>可扩展</li><li>SSH传输</li><li>幂等性</li></ol><h3 id="同类型工具"><a href="#同类型工具" class="headerlink" title="同类型工具"></a>同类型工具</h3><h4 id="曾经的竞争对手："><a href="#曾经的竞争对手：" class="headerlink" title="曾经的竞争对手："></a>曾经的竞争对手：</h4><ol><li>puppet</li><li>cfengine</li><li>chef</li><li>func</li><li>fabric</li></ol><h4 id="现在的竞争对手："><a href="#现在的竞争对手：" class="headerlink" title="现在的竞争对手："></a>现在的竞争对手：</h4><ol><li>salt</li></ol><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>Ansible的组织结构如下图所示：<br><img src="https://i.loli.net/2017/11/05/59feb2a05c5b4.png" alt="Ansible Frame"></p><p>由图可以看出，Ansible主要包含一下几个部分：</p><ol><li><p>Ansible核心引擎</p><p>提供Ansible的核心服务，用于解释和执行定义好的任务。</p></li><li><p>Modules</p><p> 包括核心modules和自定义modules。在使用Ansible执行任务时会用到modules。</p></li><li><p>Plugins</p><p> 包括连接plugins和普通plugins。其中连接plugins负责</p></li><li><p>Inventory文件</p><p> 包含Host和Host分组的信息。便于在执行任务时可以针对性的进行。</p></li><li><p>Playbooks</p><p> 由一个或多个play组成，每个play负责执行具体的任务。一个playbook则负责一整套的任务来实现一个需求。</p></li></ol><h2 id="Why-为什么使用Ansible而不是其他的工具？"><a href="#Why-为什么使用Ansible而不是其他的工具？" class="headerlink" title="Why 为什么使用Ansible而不是其他的工具？"></a><code>Why</code> 为什么使用Ansible而不是其他的工具？</h2><h3 id="Ansible能解决什么问题？"><a href="#Ansible能解决什么问题？" class="headerlink" title="Ansible能解决什么问题？"></a>Ansible能解决什么问题？</h3><ol><li>用于管理大量机器，以及机器上的大量应用</li><li>用于配置复杂的防火墙配置</li><li>管理复杂的配置文件</li><li>记录操作过程</li><li>重用配置</li></ol><h3 id="与传统方法相比"><a href="#与传统方法相比" class="headerlink" title="与传统方法相比"></a>与传统方法相比</h3><p>很多问题也可以直接使用shell脚本解决，但是当遇到需要管理的Hosts规模变大，结构越来越复杂，软硬件更新迭代加快的情况时，Shell脚本的工作量将会成倍增长。<br>更不用说普通的Shell脚本还不默认支持记录日志和重用操作过程。</p><h3 id="与类似工具相比"><a href="#与类似工具相比" class="headerlink" title="与类似工具相比"></a>与类似工具相比</h3><p>如果不用Ansible，我们也可以使用<code>puppet</code>、<code>cfengine</code>、<code>chef</code>、<code>func</code>、<code>fabric</code>这些工具。<br>这些出现时间均早于Ansible，虽然能提供足够的功能来满足需求，但这些工具普遍存在学习成本高的问题，因此一直并未非常流行。相比之下，简单易用的Ansible则受到了越来越多的关注。</p><p>除了这些相对老牌的运维工具以外，也有一些新的工具。相比之下，这些工具与Ansible比起来更有竞争力。<br>比如salt，关于<code>Salt</code>与<code>Ansible</code>的比较可以参见这篇文章《<a href="http://blog.csdn.net/a105421548/article/details/53558598">Ansible vs SaltStack 谁才是自动化运维好帮手</a>》</p><h2 id="Where-Ansible的常见使用场景"><a href="#Where-Ansible的常见使用场景" class="headerlink" title="Where Ansible的常见使用场景"></a><code>Where</code> Ansible的常见使用场景</h2><ol><li><p>使用Ad-hoc</p><p> Ad-hoc是指直接使用Ansible中的各种指令来执行一些简短的操作。比如在被管理的hosts上安装某个软件。</p></li><li><p>配置管理</p><p>使用Ansible统一的对hosts的配置进行管理。比如统一的安装某些软件。</p></li><li><p>应用部署</p><p> 通过执行预定义好的Ansible脚本，通常为playbook，来将应用部署到hosts中。该过程还包括对hosts上环境的准备过程。</p></li><li><p>管理基础设施</p><p> 可以使用Ansible来管理一大批的用来提供基础服务的hosts，简单来说就是管理提供云服务的集群中的hosts。</p></li></ol><h2 id="How-如何使用Ansible？"><a href="#How-如何使用Ansible？" class="headerlink" title="How 如何使用Ansible？"></a><code>How</code> 如何使用Ansible？</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>得益于Ansible的<code>无代理</code>特性Ansible的安装非常简单，仅需要在负责管理任务的master机器上装上Ansible，<br>然后配置该机器到其他所有slave机器的ssh无密码访问，即可开始使用。</p><h3 id="Ansible的指令"><a href="#Ansible的指令" class="headerlink" title="Ansible的指令"></a>Ansible的指令</h3><p>Ansible的指令共有9个：</p><ol><li>ansible - 用于执行单个Ansible任务</li><li>ansible-playbook - 用于执行预先定义好的playbook</li><li>ansible-vault - 用于对敏感数据进行加密</li><li>ansible-galaxy - 用于从<a href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a> 上下载第三方扩展的roles</li><li>ansible-console - 交互式地执行Ansible任务</li><li>ansible-config - 管理Ansible的配置信息</li><li>ansible-doc - 查看modules的信息</li><li>ansible-inventory - 查看Ansible当前解析得到的inventory文件信息</li><li>ansilbe-pull - 与Ansible默认的push模式对应，该指令用于以pull模式执行脚本，管理大规模hosts时使用</li></ol><h3 id="Ad-hoc"><a href="#Ad-hoc" class="headerlink" title="Ad-hoc"></a>Ad-hoc</h3><p><code>Ad-hoc</code>是一个从拉丁文引入的词汇，以为特有的，独有的。在Ansible中，该词指单独的执行Ansible的一个指令。</p><p>一个常见的执行指令的方式如下：</p><pre class=" language-yaml"><code class="language-yaml"> ansible 主机或组  <span class="token punctuation">-</span>m 模块名 <span class="token punctuation">-</span>a '模块参数'  ansible参数</code></pre><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><p><code>Playbook</code>是Ansible中被强烈推荐使用的执行方式。可以说只有使用了Playbook才能发挥出Ansible在运维方面的能力。<br>之所以这样说，是因为Playbook就好像面向对象程序中的对象，包括了很多的功能。而一个个的任务就像对象里面的方法。<br>当你需要执行某项任务的时候，使用这个对象中的方法就可以完成了。更何况你还可以将这些方法随意组合，或者应用到其他场景中。</p><p>具体来说，Playbook其实就是包含了很多Plays，真正执行任务的正是这些Plays。一个Play的结构如下图所示：</p><p><img src="https://i.loli.net/2017/11/05/59fec7bacb22c.png" alt="Play组织结构示意图"></p><p>主要包括了：</p><ol><li>target - 指定该Play作用于那些hosts</li><li>variable - 定义执行过程中用到的一些变量</li><li>task - 定义该task需要完成的任务</li><li>handler - 定义在被task中的notify通知后需要执行的任务</li><li>roles - play中可以不定义任何task，直接指定role即可，可以认为role包含了一些列task</li></ol><p>关于Ansible的具体用法，还可以参考官方给出的一些Ansible的参考<a href="https://github.com/ansible/ansible-examples">Github Repo</a>.[^1]</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>首当其冲的最佳实践就是：使用<code>Role</code>。<br>Role是一个非常好的组织任务和资源的方式，可以方便的复用到类似场景，也益于后期管理。</p><p>另外的最佳实践比如<code>在云端使用动态inventory</code>，<code>给每个任务命名</code>，<code>适当留白</code>，以及<code>版本控制</code>等等。</p><p>更多的最佳实践，可以参考Ansible官方给出的<a href="http://docs.ansible.com/ansible/latest/playbooks_best_practices.html">Ansible最佳实践</a></p><p>[^1]:<br>    <a href="https://github.com/ansible/ansible-examples">Ansible Example Repo</a>Ansible官方提供的一个用于学习Ansible用法的Github仓库，仓库中有多个Ansible使用样例。</p>]]></content>
      
      
      <categories>
          
          <category> software_engineering_efficiency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> configuration_management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费好用的Blog - Github Pages</title>
      <link href="/2017/11/01/2017-11-01-mian-fei-hao-yong-de-blog-github-pages/"/>
      <url>/2017/11/01/2017-11-01-mian-fei-hao-yong-de-blog-github-pages/</url>
      
        <content type="html"><![CDATA[<h2 id="What-什么是github-pages？"><a href="#What-什么是github-pages？" class="headerlink" title="What 什么是github pages？"></a><code>What</code> 什么是github pages？</h2><p>了解Github Pages之前，先了解一下Github。</P><p>Github是一个管理程序代码的软件，并使用Git来提供代码版本控制。很多IT项目都会在Github上托管自己的代码。可以说Github就是程序界的Facebook和Weibo。</P>Github Pages是Github提供来给用户的一个介绍自己项目的页面。它也是Github上的一个项目，用于管理这个展示页面所需的代码。用户只需要上传自己的写好的页面，然后经由jekyll[^1]处理，页面内容就可以呈现到互联网上了。<h2 id="Why-为什么要使用github-pages来写Blog？"><a href="#Why-为什么要使用github-pages来写Blog？" class="headerlink" title="Why 为什么要使用github pages来写Blog？"></a><code>Why</code> 为什么要使用github pages来写Blog？</h2><p>首先，我们会因为各种原因开始写Blog。  </P><p>通常，当我们准备要开始写，第一时间想到的可能就是诸如新浪，CSDN，简书...这样的免费空间。 </P> <p>但是，这样的免费空间毕竟限制太多，比如你想换个页面皮肤，换个布局等等，都比较难以做到完美的定制化。  </P><p>所以，我们就会想要一个独立Blog，自己建站来管理Blog。  </P><p>然后，可以搜索一下独立博客，wordpress一定是一个高频词汇。wordpress确实非常强大，可以自己修改php的代码来实现完全的定制，但是需要自己建站来提供服务，繁琐且消耗精力。  </P><p>因此，可以引出本文将要介绍的github pages，让写博客更专注于内容本身。  </P><p>上文主要介绍了三种存放blog的方式1. 使用免费空间2. 自己建站并安装诸如wordpress这样的CMS（Content Management System，内容管理系统）来管理3. 使用Github Pages</P><p>以下是目前三种方式的简单对比：</p><table><thead><tr><th align="center">方式</th><th align="left">优势</th><th align="left">劣势</th></tr></thead><tbody><tr><td align="center">免费空间</td><td align="left">1. 免费</td><td align="left">1. 定制化功能弱</td></tr><tr><td align="center"></td><td align="left">2. 无需维护</td><td align="left">2. 页面会被插入广告</td></tr><tr><td align="center"></td><td align="left">3. 服务稳定</td><td align="left"></td></tr><tr><td align="center"></td><td align="left">4. 学习成本低</td><td align="left"></td></tr><tr><td align="center">wordpress</td><td align="left">1. 可定制化页面</td><td align="left">1. 需要自己搭建网站</td></tr><tr><td align="center"></td><td align="left">2. 软件环境搭建简单</td><td align="left">2. 需要自己维护网站的运行</td></tr><tr><td align="center"></td><td align="left">3. 模板样式丰富</td><td align="left">3. 仅支持MySQL数据库</td></tr><tr><td align="center"></td><td align="left">4. 用户社区庞大</td><td align="left">4. 建站和维护均需要服务</td></tr><tr><td align="center"></td><td align="left">5. 开源软件，安全性高</td><td align="left"></td></tr><tr><td align="center">github pages</td><td align="left">1. 可定制化页面</td><td align="left">1. 仅有300M免费空间</td></tr><tr><td align="center"></td><td align="left">2. 无需建站和维护</td><td align="left">2. 需要学习Git</td></tr><tr><td align="center"></td><td align="left">3. 免费且无限流量</td><td align="left">3. 未来可能被限制流量</td></tr><tr><td align="center"></td><td align="left">4. 使用简单，快速上手</td><td align="left">4. 仅支持静态页面</td></tr><tr><td align="center"></td><td align="left">5. 使用jekyll或者Hexo可以快速布局博客主题</td><td align="left"></td></tr><tr><td align="center"></td><td align="left">6. 使用git来对Blog内容提供版本管理</td><td align="left"></td></tr></tbody></table><p>上文分析了各种方式的优劣，总结来说，我会推荐使用github pages来搭建Blog，原因如下：</p><ol><li>使用git可以很好的保管你的文章</li><li>搭建非常的简单</li><li>无需个人参与维护硬件服务</li><li>可以定制化的开发自己的Blog页面</li><li>页面有很多主体可以选择</li></ol><h2 id="How-如何使用Github-Pages来写Blog"><a href="#How-如何使用Github-Pages来写Blog" class="headerlink" title="How 如何使用Github Pages来写Blog"></a><code>How</code> 如何使用Github Pages来写Blog</h2><h3 id="从零到开始写Blog的步骤"><a href="#从零到开始写Blog的步骤" class="headerlink" title="从零到开始写Blog的步骤"></a>从零到开始写Blog的步骤</h3><p>如果现在你手头就只有电脑，那你只需要完成以下几步就可以用上Github Pages了：</p><ol><li>注册一个Github账号</li><li>新建一个<username>.github.io的github仓库</li><li>拉取现有模板到你的仓库</li><li>修改你的网站代码，编写你的Blog</li><li>Push你的网站代码和Blog到远程仓库</li><li>看到你的网站和Blog :)</li></ol><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>具体过程已经有很多Blog提及，这里推荐几个Blog，有详细的搭建过程介绍。</p><ol><li><a href="http://www.jianshu.com/p/6fdb19aa4558">手把手教你用github pages搭建博客</a></li><li><a href="http://blog.csdn.net/renfufei/article/details/37725057/">创建GitHub技术博客全攻略</a></li></ol><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>与push到github上，通过远程查看修改页面布局和内容的结果，在本地调试可以更方便快捷地确认页面布局和内容的修改。</p><p>要进行本地调试，还需要安装一些软件。大致过程如下：</p><ol><li>安装ruby环境(MacOS: brew install ruby)</li><li>安装jekyll(gem install jekyll)</li><li>启动jekyll服务(bundle exec jekyll serve)</li><li>在浏览器中查看你的网页(localhost:4000)</li></ol><p>具体安装过程，可以参考如下博客：</p><ol><li><a href="http://www.jianshu.com/p/88e3474cef72">在windows下安装jekyll</a></li><li><a href="http://www.jianshu.com/p/f37a96f83d51">Jekyll本地搭建开发环境以及Github部署流程</a></li></ol><p>如果发现如下错误：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">in</span> `<span class="token keyword">require</span>'<span class="token punctuation">:</span> cannot load such file <span class="token operator">--</span> <span class="token function">bundler</span> <span class="token punctuation">(</span><span class="token constant">LoadError</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 你需要执行</span>$ gem install bundle</code></pre><pre class=" language-ruby"><code class="language-ruby"> <span class="token constant">Could</span> <span class="token keyword">not</span> find concurrent<span class="token operator">-</span>ruby<span class="token number">-1.0</span><span class="token punctuation">.</span><span class="token number">5</span> <span class="token keyword">in</span> any of the <span class="token function">sources</span> <span class="token punctuation">(</span><span class="token constant">Bundler</span><span class="token punctuation">:</span><span class="token symbol">:GemNotFound</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 你需要执行</span>$ bundle update</code></pre><h3 id="运行中的问题"><a href="#运行中的问题" class="headerlink" title="运行中的问题"></a>运行中的问题</h3><pre class=" language-ruby"><code class="language-ruby"> <span class="token constant">Conversion</span> error<span class="token punctuation">:</span> <span class="token constant">Jekyll</span><span class="token punctuation">:</span><span class="token symbol">:Converters</span><span class="token punctuation">:</span><span class="token symbol">:Scss</span> encountered an error <span class="token keyword">while</span> converting <span class="token string">'style.scss'</span><span class="token punctuation">:</span>                    <span class="token constant">Invalid</span> <span class="token constant">GBK</span> character <span class="token string">"\xE2"</span> on line <span class="token number">1</span></code></pre><p>可以参考该<a href="https://segmentfault.com/a/1190000002932352">ruby编译scss出现invalid GBK错误</a>中的解决办法</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> github_pages </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
