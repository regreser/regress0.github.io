<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SeeYu</title><link>https://www.notes.wang/</link><description>Recent content on SeeYu</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.notes.wang/index.xml" rel="self" type="application/rss+xml"/><item><title>学软件技术一定要实战？</title><link>https://www.notes.wang/post/%E5%AD%A6%E8%BD%AF%E4%BB%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AE%9E%E6%88%98/</link><pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.notes.wang/post/%E5%AD%A6%E8%BD%AF%E4%BB%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AE%9E%E6%88%98/</guid><description>
学习软件技术要实战，可能是多数从业者的共识。但为什么学习软件技术要实战？实战无论是寻找合适的实战项目还是进行实战需要的时间都要比阅读一本技术书籍或者技术博客的投入要高得多的多得多&amp;hellip;所以如果不实战，就没有办法学好软件？不得不说，进行实战时，虽然会投入更多的时间和精力，但也确实能将知识掌握的更牢靠，或者说知识留存率更高，这大概也是学习软件技术要实战的共识由来。但这也并不意味着学习软件技术一定要实战。
实战能更好地掌握软件技术的原因在于，实战能给你提供更多的上下文，而不只是你想要学的。在实战中，你以为你只学到了一个知识点，实际上你学到了可能十几个甚至更多的知识点。而且这些知识点都围绕着同一个场景展开，可以更容易地被吸收进你自身的知识体系，从而就更容易被运用。最终就让人觉得实战能够将知识掌握得更牢靠，换句话说就是会用了。而你通过读书学来的东西，则直截了当得多，往往就只有那一个知识点，针对性很强。这些点状得知识，并没有那么容易和你自己得知识体系融合，进而被你运用。
之所以要实战，关键在于实战可以给你： 1. 学到更多相关联的知识，形成知识网络，而不仅是知识点； 2. 知识对应的应用场景信息，包括问题的发生原因、解决经过、解决结果。
那如果在阅读技术书籍和博客的过程中就能做到这两点，那是不是就能达到接近实战的学习效果呢？我认为答案是肯定的。
首先关于第一个关键点：学习知识网络，而非知识点。举个简单的例子，在学习一门新的程序语言的时候，与之前学习的程序语言做对比。根据对之前程序语言的学习经验，抽象一些需要掌握的模块，比如设计思想，亮点，基本语法，提供的方法库，著名的项目等。通过读书来了解这门新语言后，知识或多或少就和已经掌握的语言建立了一个连接，这可以帮助我们更快速高效地掌握了这门新语言。
当然这还不够，这样的连接还是相对较弱，所以关注第二个关键点，帮助我们促进新知识和已有知识网络的融合。可以在读书的过程中，不断地思考，向自己发问，诸如“这个程序语言用来开发这样的项目为什么会更合适？”，“为什么这门程序语言会更适合高并发？”等等。这些问题都是这门语言的应用场景，在不断地弄清楚这些问题的过程中，实际上也就是在不断地学习具体应用场景，进而不断地加强新知识与已有知识的连接。
实战并非学习技术的唯一途径，但实战绝对是软件从业者最重要的学习手段之一。只是在我们无法获得这些实战机会的时候，记得学习软件技术并非一定要实战。</description></item><item><title>签名你的Git提交</title><link>https://www.notes.wang/post/%E7%AD%BE%E5%90%8D%E4%BD%A0%E7%9A%84git%E6%8F%90%E4%BA%A4/</link><pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.notes.wang/post/%E7%AD%BE%E5%90%8D%E4%BD%A0%E7%9A%84git%E6%8F%90%E4%BA%A4/</guid><description>
目录 什么是签名Git的提交？
Git提交为什么需要签名？
如何签名？
原理解析
引用
什么是签名Git的提交？
1. 什么是签名Git的提交？ 下图是一张被签名过后的提交(Commit)，在Github上的展示：
与普通Commit的区别在于其多了一个Verified标识。这个标识能够被所有有权查看Commit的人看到，从而让大家更加信任这个Commit确实是作者本人提交的。而签名Git的提交正是显示Verified标识的最核心的一步。
2. Git提交为什么需要签名？ 简单来说就是避免自己或者他人的Commit被伪造。
如今Git已然成为源码管理领域的重要成员，无数程序员使用Git作为其源码管理工具。那些以Git为核心的各种商业软件，如Github，Gitlab，Bitbucket等，每天接收大量的Git Commits。毫无疑问，这些Commit就是企业最重要的财产。即便如此，对于Commit本身的安全性，却没有得到太多的重视。当然Commit本身只是Git软件下的一个重要概念，保护Git软件的安全一定程度也能够保障Commit的安全，但这绝不是一个好的将Commit的安全放任不管的理由。要知道如果你什么都不做，Repository中的Commit是可以轻易被伪造的。而签名Git的提交正是为了解决这个问题而来。
3. 如何签名？ 签名本身是一个简单的动作，尤其是在Git 2.34版本后，支持了SSH签名，对于那些本就使用SSH验证身份的用户就更加容易了。Github也支持使用GPG或者S/MIME进行签名，不过GPG相比于SSH更加复杂，S/MIME则主要用于企业。这里的例子以相对简单的Github上的SSH签名来演示。
生成密钥对 使用以下命令生成Key-Pair[1]
$ ssh-keygen -t ed25519 -C &amp;quot;your_email@example.com&amp;quot;
建议使用ed25519，相比于rsa 4096bit更快的速度，同时安全性也没有损失太多。
配置Github 打开“setting”页面的“SSH and GPG keys”：
将上一步生成的公钥xxx.pub中的内容作为Signing Key上传到Github： 签名部分的配置就完成了，为了在Github上显示Verified标识，还需要打开“SSH and GPG keys”页面里的“Vigilant mode”[2]： 配置git[3] 配置Git使用SSH来签名Commit
$ git config --global gpg.format ssh
配置Git使用指定路径的公钥作为SSH的Signing Key
$ git config --global user.signingkey ~/.ssh/ed25519.pub
配置IDE（IntelliJ为例） 在commit页面上，点击设置，并勾选“Sign-off commit”，如下图所示： 签名并提交 $ git commit -S -m &amp;quot;this is a signed commit&amp;quot;</description></item></channel></rss>